{"ast":null,"code":"/*! RowGroup 1.1.4\n * Â©2017-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     RowGroup\n * @description RowGrouping for DataTables\n * @version     1.1.4\n * @file        dataTables.rowGroup.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     datatables.net\n * @copyright   Copyright 2017-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery', 'datatables.net'], function ($) {\n      return factory($, window, document);\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = function (root, $) {\n      if (!root) {\n        root = window;\n      }\n\n      if (!$ || !$.fn.dataTable) {\n        $ = require('datatables.net')(root, $).$;\n      }\n\n      return factory($, root, root.document);\n    };\n  } else {\n    // Browser\n    factory(jQuery, window, document);\n  }\n})(function ($, window, document, undefined) {\n  'use strict';\n\n  var DataTable = $.fn.dataTable;\n\n  var RowGroup = function RowGroup(dt, opts) {\n    // Sanity check that we are using DataTables 1.10 or newer\n    if (!DataTable.versionCheck || !DataTable.versionCheck('1.10.8')) {\n      throw 'RowGroup requires DataTables 1.10.8 or newer';\n    } // User and defaults configuration object\n\n\n    this.c = $.extend(true, {}, DataTable.defaults.rowGroup, RowGroup.defaults, opts); // Internal settings\n\n    this.s = {\n      dt: new DataTable.Api(dt)\n    }; // DOM items\n\n    this.dom = {}; // Check if row grouping has already been initialised on this table\n\n    var settings = this.s.dt.settings()[0];\n    var existing = settings.rowGroup;\n\n    if (existing) {\n      return existing;\n    }\n\n    settings.rowGroup = this;\n\n    this._constructor();\n  };\n\n  $.extend(RowGroup.prototype, {\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * API methods for DataTables API interface\n     */\n\n    /**\n     * Get/set the grouping data source - need to call draw after this is\n     * executed as a setter\n     * @returns string~RowGroup\n     */\n    dataSrc: function dataSrc(val) {\n      if (val === undefined) {\n        return this.c.dataSrc;\n      }\n\n      var dt = this.s.dt;\n      this.c.dataSrc = val;\n      $(dt.table().node()).triggerHandler('rowgroup-datasrc.dt', [dt, val]);\n      return this;\n    },\n\n    /**\n     * Disable - need to call draw after this is executed\n     * @returns RowGroup\n     */\n    disable: function disable() {\n      this.c.enable = false;\n      return this;\n    },\n\n    /**\n     * Enable - need to call draw after this is executed\n     * @returns RowGroup\n     */\n    enable: function enable(flag) {\n      if (flag === false) {\n        return this.disable();\n      }\n\n      this.c.enable = true;\n      return this;\n    },\n\n    /**\n     * Get enabled flag\n     * @returns boolean\n     */\n    enabled: function enabled() {\n      return this.c.enable;\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Constructor\n     */\n    _constructor: function _constructor() {\n      var that = this;\n      var dt = this.s.dt;\n      var hostSettings = dt.settings()[0];\n      dt.on('draw.dtrg', function (e, s) {\n        if (that.c.enable && hostSettings === s) {\n          that._draw();\n        }\n      });\n      dt.on('column-visibility.dt.dtrg responsive-resize.dt.dtrg', function () {\n        that._adjustColspan();\n      });\n      dt.on('destroy', function () {\n        dt.off('.dtrg');\n      });\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Private methods\n     */\n\n    /**\n     * Adjust column span when column visibility changes\n     * @private\n     */\n    _adjustColspan: function _adjustColspan() {\n      $('tr.' + this.c.className, this.s.dt.table().body()).find('td:visible').attr('colspan', this._colspan());\n    },\n\n    /**\n     * Get the number of columns that a grouping row should span\n     * @private\n     */\n    _colspan: function _colspan() {\n      return this.s.dt.columns().visible().reduce(function (a, b) {\n        return a + b;\n      }, 0);\n    },\n\n    /**\n     * Update function that is called whenever we need to draw the grouping rows.\n     * This is basically a bootstrap for the self iterative _group and _groupDisplay\n     * methods\n     * @private\n     */\n    _draw: function _draw() {\n      var dt = this.s.dt;\n\n      var groupedRows = this._group(0, dt.rows({\n        page: 'current'\n      }).indexes());\n\n      this._groupDisplay(0, groupedRows);\n    },\n\n    /**\n     * Get the grouping information from a data set (index) of rows\n     * @param {number} level Nesting level\n     * @param {DataTables.Api} rows API of the rows to consider for this group\n     * @returns {object[]} Nested grouping information - it is structured like this:\n     *\t{\n     *\t\tdataPoint: 'Edinburgh',\n     *\t\trows: [ 1,2,3,4,5,6,7 ],\n     *\t\tchildren: [ {\n     *\t\t\tdataPoint: 'developer'\n     *\t\t\trows: [ 1, 2, 3 ]\n     *\t\t},\n     *\t\t{\n     *\t\t\tdataPoint: 'support',\n     *\t\t\trows: [ 4, 5, 6, 7 ]\n     *\t\t} ]\n     *\t}\n     * @private\n     */\n    _group: function _group(level, rows) {\n      var fns = Array.isArray(this.c.dataSrc) ? this.c.dataSrc : [this.c.dataSrc];\n\n      var fn = DataTable.ext.oApi._fnGetObjectDataFn(fns[level]);\n\n      var dt = this.s.dt;\n      var group, last;\n      var data = [];\n      var that = this;\n\n      for (var i = 0, ien = rows.length; i < ien; i++) {\n        var rowIndex = rows[i];\n        var rowData = dt.row(rowIndex).data();\n        var group = fn(rowData);\n\n        if (group === null || group === undefined) {\n          group = that.c.emptyDataGroup;\n        }\n\n        if (last === undefined || group !== last) {\n          data.push({\n            dataPoint: group,\n            rows: []\n          });\n          last = group;\n        }\n\n        data[data.length - 1].rows.push(rowIndex);\n      }\n\n      if (fns[level + 1] !== undefined) {\n        for (var i = 0, ien = data.length; i < ien; i++) {\n          data[i].children = this._group(level + 1, data[i].rows);\n        }\n      }\n\n      return data;\n    },\n\n    /**\n     * Row group display - insert the rows into the document\n     * @param {number} level Nesting level\n     * @param {object[]} groups Takes the nested array from `_group`\n     * @private\n     */\n    _groupDisplay: function _groupDisplay(level, groups) {\n      var dt = this.s.dt;\n      var display;\n\n      for (var i = 0, ien = groups.length; i < ien; i++) {\n        var group = groups[i];\n        var groupName = group.dataPoint;\n        var row;\n        var rows = group.rows;\n\n        if (this.c.startRender) {\n          display = this.c.startRender.call(this, dt.rows(rows), groupName, level);\n          row = this._rowWrap(display, this.c.startClassName, level);\n\n          if (row) {\n            row.insertBefore(dt.row(rows[0]).node());\n          }\n        }\n\n        if (this.c.endRender) {\n          display = this.c.endRender.call(this, dt.rows(rows), groupName, level);\n          row = this._rowWrap(display, this.c.endClassName, level);\n\n          if (row) {\n            row.insertAfter(dt.row(rows[rows.length - 1]).node());\n          }\n        }\n\n        if (group.children) {\n          this._groupDisplay(level + 1, group.children);\n        }\n      }\n    },\n\n    /**\n     * Take a rendered value from an end user and make it suitable for display\n     * as a row, by wrapping it in a row, or detecting that it is a row.\n     * @param {node|jQuery|string} display Display value\n     * @param {string} className Class to add to the row\n     * @param {array} group\n     * @param {number} group level\n     * @private\n     */\n    _rowWrap: function _rowWrap(display, className, level) {\n      var row;\n\n      if (display === null || display === '') {\n        display = this.c.emptyDataGroup;\n      }\n\n      if (display === undefined || display === null) {\n        return null;\n      }\n\n      if (typeof display === 'object' && display.nodeName && display.nodeName.toLowerCase() === 'tr') {\n        row = $(display);\n      } else if (display instanceof $ && display.length && display[0].nodeName.toLowerCase() === 'tr') {\n        row = display;\n      } else {\n        row = $('<tr/>').append($('<td/>').attr('colspan', this._colspan()).append(display));\n      }\n\n      return row.addClass(this.c.className).addClass(className).addClass('dtrg-level-' + level);\n    }\n  });\n  /**\n   * RowGroup default settings for initialisation\n   *\n   * @namespace\n   * @name RowGroup.defaults\n   * @static\n   */\n\n  RowGroup.defaults = {\n    /**\n     * Class to apply to grouping rows - applied to both the start and\n     * end grouping rows.\n     * @type string\n     */\n    className: 'dtrg-group',\n\n    /**\n     * Data property from which to read the grouping information\n     * @type string|integer|array\n     */\n    dataSrc: 0,\n\n    /**\n     * Text to show if no data is found for a group\n     * @type string\n     */\n    emptyDataGroup: 'No group',\n\n    /**\n     * Initial enablement state\n     * @boolean\n     */\n    enable: true,\n\n    /**\n     * Class name to give to the end grouping row\n     * @type string\n     */\n    endClassName: 'dtrg-end',\n\n    /**\n     * End grouping label function\n     * @function\n     */\n    endRender: null,\n\n    /**\n     * Class name to give to the start grouping row\n     * @type string\n     */\n    startClassName: 'dtrg-start',\n\n    /**\n     * Start grouping label function\n     * @function\n     */\n    startRender: function startRender(rows, group) {\n      return group;\n    }\n  };\n  RowGroup.version = \"1.1.4\";\n  $.fn.dataTable.RowGroup = RowGroup;\n  $.fn.DataTable.RowGroup = RowGroup;\n  DataTable.Api.register('rowGroup()', function () {\n    return this;\n  });\n  DataTable.Api.register('rowGroup().disable()', function () {\n    return this.iterator('table', function (ctx) {\n      if (ctx.rowGroup) {\n        ctx.rowGroup.enable(false);\n      }\n    });\n  });\n  DataTable.Api.register('rowGroup().enable()', function (opts) {\n    return this.iterator('table', function (ctx) {\n      if (ctx.rowGroup) {\n        ctx.rowGroup.enable(opts === undefined ? true : opts);\n      }\n    });\n  });\n  DataTable.Api.register('rowGroup().enabled()', function () {\n    var ctx = this.context;\n    return ctx.length && ctx[0].rowGroup ? ctx[0].rowGroup.enabled() : false;\n  });\n  DataTable.Api.register('rowGroup().dataSrc()', function (val) {\n    if (val === undefined) {\n      return this.context[0].rowGroup.dataSrc();\n    }\n\n    return this.iterator('table', function (ctx) {\n      if (ctx.rowGroup) {\n        ctx.rowGroup.dataSrc(val);\n      }\n    });\n  }); // Attach a listener to the document which listens for DataTables initialisation\n  // events so we can automatically initialise\n\n  $(document).on('preInit.dt.dtrg', function (e, settings, json) {\n    if (e.namespace !== 'dt') {\n      return;\n    }\n\n    var init = settings.oInit.rowGroup;\n    var defaults = DataTable.defaults.rowGroup;\n\n    if (init || defaults) {\n      var opts = $.extend({}, defaults, init);\n\n      if (init !== false) {\n        new RowGroup(settings, opts);\n      }\n    }\n  });\n  return RowGroup;\n});","map":null,"metadata":{},"sourceType":"script"}