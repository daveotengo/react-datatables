{"ast":null,"code":"/*! FixedHeader 3.2.2\n * Â©2009-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     FixedHeader\n * @description Fix a table's header or footer, so it is always visible while\n *              scrolling\n * @version     3.2.2\n * @file        dataTables.fixedHeader.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2009-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery', 'datatables.net'], function ($) {\n      return factory($, window, document);\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = function (root, $) {\n      if (!root) {\n        root = window;\n      }\n\n      if (!$ || !$.fn.dataTable) {\n        $ = require('datatables.net')(root, $).$;\n      }\n\n      return factory($, root, root.document);\n    };\n  } else {\n    // Browser\n    factory(jQuery, window, document);\n  }\n})(function ($, window, document, undefined) {\n  'use strict';\n\n  var DataTable = $.fn.dataTable;\n  var _instCounter = 0;\n\n  var FixedHeader = function FixedHeader(dt, config) {\n    // Sanity check - you just know it will happen\n    if (!(this instanceof FixedHeader)) {\n      throw \"FixedHeader must be initialised with the 'new' keyword.\";\n    } // Allow a boolean true for defaults\n\n\n    if (config === true) {\n      config = {};\n    }\n\n    dt = new DataTable.Api(dt);\n    this.c = $.extend(true, {}, FixedHeader.defaults, config);\n    this.s = {\n      dt: dt,\n      position: {\n        theadTop: 0,\n        tbodyTop: 0,\n        tfootTop: 0,\n        tfootBottom: 0,\n        width: 0,\n        left: 0,\n        tfootHeight: 0,\n        theadHeight: 0,\n        windowHeight: $(window).height(),\n        visible: true\n      },\n      headerMode: null,\n      footerMode: null,\n      autoWidth: dt.settings()[0].oFeatures.bAutoWidth,\n      namespace: '.dtfc' + _instCounter++,\n      scrollLeft: {\n        header: -1,\n        footer: -1\n      },\n      enable: true\n    };\n    this.dom = {\n      floatingHeader: null,\n      thead: $(dt.table().header()),\n      tbody: $(dt.table().body()),\n      tfoot: $(dt.table().footer()),\n      header: {\n        host: null,\n        floating: null,\n        floatingParent: $('<div class=\"dtfh-floatingparent\">'),\n        placeholder: null\n      },\n      footer: {\n        host: null,\n        floating: null,\n        floatingParent: $('<div class=\"dtfh-floatingparent\">'),\n        placeholder: null\n      }\n    };\n    this.dom.header.host = this.dom.thead.parent();\n    this.dom.footer.host = this.dom.tfoot.parent();\n    var dtSettings = dt.settings()[0];\n\n    if (dtSettings._fixedHeader) {\n      throw \"FixedHeader already initialised on table \" + dtSettings.nTable.id;\n    }\n\n    dtSettings._fixedHeader = this;\n\n    this._constructor();\n  };\n  /*\n   * Variable: FixedHeader\n   * Purpose:  Prototype for FixedHeader\n   * Scope:    global\n   */\n\n\n  $.extend(FixedHeader.prototype, {\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * API methods\n     */\n\n    /**\n     * Kill off FH and any events\n     */\n    destroy: function destroy() {\n      var dom = this.dom;\n      this.s.dt.off('.dtfc');\n      $(window).off(this.s.namespace); // Remove clones of FC blockers\n\n      if (dom.header.rightBlocker) {\n        dom.header.rightBlocker.remove();\n      }\n\n      if (dom.header.leftBlocker) {\n        dom.header.leftBlocker.remove();\n      }\n\n      if (dom.footer.rightBlocker) {\n        dom.footer.rightBlocker.remove();\n      }\n\n      if (dom.footer.leftBlocker) {\n        dom.footer.leftBlocker.remove();\n      }\n\n      if (this.c.header) {\n        this._modeChange('in-place', 'header', true);\n      }\n\n      if (this.c.footer && dom.tfoot.length) {\n        this._modeChange('in-place', 'footer', true);\n      }\n    },\n\n    /**\n     * Enable / disable the fixed elements\n     *\n     * @param  {boolean} enable `true` to enable, `false` to disable\n     */\n    enable: function enable(_enable, update) {\n      this.s.enable = _enable;\n\n      if (update || update === undefined) {\n        this._positions();\n\n        this._scroll(true);\n      }\n    },\n\n    /**\n     * Get enabled status\n     */\n    enabled: function enabled() {\n      return this.s.enable;\n    },\n\n    /**\n     * Set header offset \n     *\n     * @param  {int} new value for headerOffset\n     */\n    headerOffset: function headerOffset(offset) {\n      if (offset !== undefined) {\n        this.c.headerOffset = offset;\n        this.update();\n      }\n\n      return this.c.headerOffset;\n    },\n\n    /**\n     * Set footer offset\n     *\n     * @param  {int} new value for footerOffset\n     */\n    footerOffset: function footerOffset(offset) {\n      if (offset !== undefined) {\n        this.c.footerOffset = offset;\n        this.update();\n      }\n\n      return this.c.footerOffset;\n    },\n\n    /**\n     * Recalculate the position of the fixed elements and force them into place\n     */\n    update: function update(force) {\n      var table = this.s.dt.table().node();\n\n      if ($(table).is(':visible')) {\n        this.enable(true, false);\n      } else {\n        this.enable(false, false);\n      } // Don't update if header is not in the document atm (due to\n      // async events)\n\n\n      if ($(table).children('thead').length === 0) {\n        return;\n      }\n\n      this._positions();\n\n      this._scroll(force !== undefined ? force : true);\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Constructor\n     */\n\n    /**\n     * FixedHeader constructor - adding the required event listeners and\n     * simple initialisation\n     *\n     * @private\n     */\n    _constructor: function _constructor() {\n      var that = this;\n      var dt = this.s.dt;\n      $(window).on('scroll' + this.s.namespace, function () {\n        that._scroll();\n      }).on('resize' + this.s.namespace, DataTable.util.throttle(function () {\n        that.s.position.windowHeight = $(window).height();\n        that.update();\n      }, 50));\n      var autoHeader = $('.fh-fixedHeader');\n\n      if (!this.c.headerOffset && autoHeader.length) {\n        this.c.headerOffset = autoHeader.outerHeight();\n      }\n\n      var autoFooter = $('.fh-fixedFooter');\n\n      if (!this.c.footerOffset && autoFooter.length) {\n        this.c.footerOffset = autoFooter.outerHeight();\n      }\n\n      dt.on('column-reorder.dt.dtfc column-visibility.dt.dtfc column-sizing.dt.dtfc responsive-display.dt.dtfc', function (e, ctx) {\n        that.update();\n      }).on('draw.dt.dtfc', function (e, ctx) {\n        // For updates from our own table, don't reclone, but for all others, do\n        that.update(ctx === dt.settings()[0] ? false : true);\n      });\n      dt.on('destroy.dtfc', function () {\n        that.destroy();\n      });\n\n      this._positions();\n\n      this._scroll();\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Private methods\n     */\n\n    /**\n     * Clone a fixed item to act as a place holder for the original element\n     * which is moved into a clone of the table element, and moved around the\n     * document to give the fixed effect.\n     *\n     * @param  {string}  item  'header' or 'footer'\n     * @param  {boolean} force Force the clone to happen, or allow automatic\n     *   decision (reuse existing if available)\n     * @private\n     */\n    _clone: function _clone(item, force) {\n      var that = this;\n      var dt = this.s.dt;\n      var itemDom = this.dom[item];\n      var itemElement = item === 'header' ? this.dom.thead : this.dom.tfoot; // If footer and scrolling is enabled then we don't clone\n      // Instead the table's height is decreased accordingly - see `_scroll()`\n\n      if (item === 'footer' && this._scrollEnabled()) {\n        return;\n      }\n\n      if (!force && itemDom.floating) {\n        // existing floating element - reuse it\n        itemDom.floating.removeClass('fixedHeader-floating fixedHeader-locked');\n      } else {\n        if (itemDom.floating) {\n          if (itemDom.placeholder !== null) {\n            itemDom.placeholder.remove();\n          }\n\n          this._unsize(item);\n\n          itemDom.floating.children().detach();\n          itemDom.floating.remove();\n        }\n\n        var tableNode = $(dt.table().node());\n        var scrollBody = $(tableNode.parent());\n\n        var scrollEnabled = this._scrollEnabled();\n\n        var docScrollLeft = $(document).scrollLeft();\n        var docScrollTop = $(document).scrollTop();\n        itemDom.floating = $(dt.table().node().cloneNode(false)).attr('aria-hidden', 'true').css({\n          'table-layout': 'fixed',\n          top: 0,\n          left: 0\n        }).removeAttr('id').append(itemElement);\n        itemDom.floatingParent.css({\n          width: scrollBody.width(),\n          overflow: 'hidden',\n          height: 'fit-content',\n          position: 'fixed',\n          left: scrollEnabled ? tableNode.offset().left + scrollBody.scrollLeft() : 0\n        }).css(item === 'header' ? {\n          top: this.c.headerOffset,\n          bottom: ''\n        } : {\n          top: '',\n          bottom: this.c.footerOffset\n        }).addClass(item === 'footer' ? 'dtfh-floatingparentfoot' : 'dtfh-floatingparenthead').append(itemDom.floating).appendTo('body');\n\n        this._stickyPosition(itemDom.floating, '-');\n\n        var scrollLeftUpdate = function scrollLeftUpdate() {\n          var scrollLeft = scrollBody.scrollLeft();\n          that.s.scrollLeft = {\n            footer: scrollLeft,\n            header: scrollLeft\n          };\n          itemDom.floatingParent.scrollLeft(that.s.scrollLeft.header);\n        };\n\n        scrollLeftUpdate();\n        scrollBody.off('scroll.dtfh').on('scroll.dtfh', scrollLeftUpdate); // Insert a fake thead/tfoot into the DataTable to stop it jumping around\n\n        itemDom.placeholder = itemElement.clone(false);\n        itemDom.placeholder.find('*[id]').removeAttr('id');\n        itemDom.host.prepend(itemDom.placeholder); // Clone widths\n\n        this._matchWidths(itemDom.placeholder, itemDom.floating); // The above action will remove the table header, potentially causing the table to\n        // collapse to a smaller size, before it is then re-inserted (append). The result\n        // can be that the document, if scrolling, can \"jump\".\n\n\n        $(document).scrollTop(docScrollTop).scrollLeft(docScrollLeft);\n      }\n    },\n\n    /**\n     * This method sets the sticky position of the header elements to match fixed columns\n     * @param {JQuery<HTMLElement>} el \n     * @param {string} sign \n     */\n    _stickyPosition: function _stickyPosition(el, sign) {\n      if (this._scrollEnabled()) {\n        var that = this;\n        var rtl = $(that.s.dt.table().node()).css('direction') === 'rtl';\n        el.find('th').each(function () {\n          // Find out if fixed header has previously set this column\n          if ($(this).css('position') === 'sticky') {\n            var right = $(this).css('right');\n            var left = $(this).css('left');\n\n            if (right !== 'auto' && !rtl) {\n              // New position either adds or dismisses the barWidth\n              var potential = +right.replace(/px/g, '') + (sign === '-' ? -1 : 1) * that.s.dt.settings()[0].oBrowser.barWidth;\n              $(this).css('right', potential > 0 ? potential : 0);\n            } else if (left !== 'auto' && rtl) {\n              var potential = +left.replace(/px/g, '') + (sign === '-' ? -1 : 1) * that.s.dt.settings()[0].oBrowser.barWidth;\n              $(this).css('left', potential > 0 ? potential : 0);\n            }\n          }\n        });\n      }\n    },\n\n    /**\n     * Copy widths from the cells in one element to another. This is required\n     * for the footer as the footer in the main table takes its sizes from the\n     * header columns. That isn't present in the footer so to have it still\n     * align correctly, the sizes need to be copied over. It is also required\n     * for the header when auto width is not enabled\n     *\n     * @param  {jQuery} from Copy widths from\n     * @param  {jQuery} to   Copy widths to\n     * @private\n     */\n    _matchWidths: function _matchWidths(from, to) {\n      var get = function get(name) {\n        return $(name, from).map(function () {\n          return $(this).css('width').replace(/[^\\d\\.]/g, '') * 1;\n        }).toArray();\n      };\n\n      var set = function set(name, toWidths) {\n        $(name, to).each(function (i) {\n          $(this).css({\n            width: toWidths[i],\n            minWidth: toWidths[i]\n          });\n        });\n      };\n\n      var thWidths = get('th');\n      var tdWidths = get('td');\n      set('th', thWidths);\n      set('td', tdWidths);\n    },\n\n    /**\n     * Remove assigned widths from the cells in an element. This is required\n     * when inserting the footer back into the main table so the size is defined\n     * by the header columns and also when auto width is disabled in the\n     * DataTable.\n     *\n     * @param  {string} item The `header` or `footer`\n     * @private\n     */\n    _unsize: function _unsize(item) {\n      var el = this.dom[item].floating;\n\n      if (el && (item === 'footer' || item === 'header' && !this.s.autoWidth)) {\n        $('th, td', el).css({\n          width: '',\n          minWidth: ''\n        });\n      } else if (el && item === 'header') {\n        $('th, td', el).css('min-width', '');\n      }\n    },\n\n    /**\n     * Reposition the floating elements to take account of horizontal page\n     * scroll\n     *\n     * @param  {string} item       The `header` or `footer`\n     * @param  {int}    scrollLeft Document scrollLeft\n     * @private\n     */\n    _horizontal: function _horizontal(item, scrollLeft) {\n      var itemDom = this.dom[item];\n      var position = this.s.position;\n      var lastScrollLeft = this.s.scrollLeft;\n\n      if (itemDom.floating && lastScrollLeft[item] !== scrollLeft) {\n        // If scrolling is enabled we need to match the floating header to the body\n        if (this._scrollEnabled()) {\n          var newScrollLeft = $($(this.s.dt.table().node()).parent()).scrollLeft();\n          itemDom.floating.scrollLeft(newScrollLeft);\n          itemDom.floatingParent.scrollLeft(newScrollLeft);\n        }\n\n        lastScrollLeft[item] = scrollLeft;\n      }\n    },\n\n    /**\n     * Change from one display mode to another. Each fixed item can be in one\n     * of:\n     *\n     * * `in-place` - In the main DataTable\n     * * `in` - Floating over the DataTable\n     * * `below` - (Header only) Fixed to the bottom of the table body\n     * * `above` - (Footer only) Fixed to the top of the table body\n     * \n     * @param  {string}  mode        Mode that the item should be shown in\n     * @param  {string}  item        'header' or 'footer'\n     * @param  {boolean} forceChange Force a redraw of the mode, even if already\n     *     in that mode.\n     * @private\n     */\n    _modeChange: function _modeChange(mode, item, forceChange) {\n      var dt = this.s.dt;\n      var itemDom = this.dom[item];\n      var position = this.s.position; // Just determine if scroll is enabled once\n\n      var scrollEnabled = this._scrollEnabled(); // If footer and scrolling is enabled then we don't clone\n      // Instead the table's height is decreased accordingly - see `_scroll()`\n\n\n      if (item === 'footer' && scrollEnabled) {\n        return;\n      } // It isn't trivial to add a !important css attribute...\n\n\n      var importantWidth = function importantWidth(w) {\n        itemDom.floating.attr('style', function (i, s) {\n          return (s || '') + 'width: ' + w + 'px !important;';\n        }); // If not scrolling also have to update the floatingParent\n\n        if (!scrollEnabled) {\n          itemDom.floatingParent.attr('style', function (i, s) {\n            return (s || '') + 'width: ' + w + 'px !important;';\n          });\n        }\n      }; // Record focus. Browser's will cause input elements to loose focus if\n      // they are inserted else where in the doc\n\n\n      var tablePart = this.dom[item === 'footer' ? 'tfoot' : 'thead'];\n      var focus = $.contains(tablePart[0], document.activeElement) ? document.activeElement : null;\n      var scrollBody = $($(this.s.dt.table().node()).parent());\n\n      if (mode === 'in-place') {\n        // Insert the header back into the table's real header\n        if (itemDom.placeholder) {\n          itemDom.placeholder.remove();\n          itemDom.placeholder = null;\n        }\n\n        this._unsize(item);\n\n        if (item === 'header') {\n          itemDom.host.prepend(tablePart);\n        } else {\n          itemDom.host.append(tablePart);\n        }\n\n        if (itemDom.floating) {\n          itemDom.floating.remove();\n          itemDom.floating = null;\n\n          this._stickyPosition(itemDom.host, '+');\n        }\n\n        if (itemDom.floatingParent) {\n          itemDom.floatingParent.remove();\n        }\n\n        $($(itemDom.host.parent()).parent()).scrollLeft(scrollBody.scrollLeft());\n      } else if (mode === 'in') {\n        // Remove the header from the read header and insert into a fixed\n        // positioned floating table clone\n        this._clone(item, forceChange); // Get useful position values\n\n\n        var scrollOffset = scrollBody.offset();\n        var windowTop = $(document).scrollTop();\n        var windowHeight = $(window).height();\n        var windowBottom = windowTop + windowHeight;\n        var bodyTop = scrollEnabled ? scrollOffset.top : position.tbodyTop;\n        var bodyBottom = scrollEnabled ? scrollOffset.top + scrollBody.outerHeight() : position.tfootTop; // Calculate the amount that the footer or header needs to be shuffled\n\n        var shuffle = item === 'footer' ? // footer and top of body isn't on screen\n        bodyTop > windowBottom ? // Yes - push the footer below\n        position.tfootHeight : // No - bottom set to the gap between the top of the body and the bottom of the window\n        bodyTop + position.tfootHeight - windowBottom : // Otherwise must be a header so get the difference from the bottom of the\n        //  desired floating header and the bottom of the table body\n        windowTop + this.c.headerOffset + position.theadHeight - bodyBottom; // Set the top or bottom based off of the offset and the shuffle value\n\n        var prop = item === 'header' ? 'top' : 'bottom';\n        var val = this.c[item + 'Offset'] - (shuffle > 0 ? shuffle : 0);\n        itemDom.floating.addClass('fixedHeader-floating');\n        itemDom.floatingParent.css(prop, val).css({\n          'left': position.left,\n          'height': item === 'header' ? position.theadHeight : position.tfootHeight,\n          'z-index': 2\n        }).append(itemDom.floating);\n        importantWidth(position.width);\n\n        if (item === 'footer') {\n          itemDom.floating.css('top', '');\n        }\n      } else if (mode === 'below') {\n        // only used for the header\n        // Fix the position of the floating header at base of the table body\n        this._clone(item, forceChange);\n\n        itemDom.floating.addClass('fixedHeader-locked');\n        itemDom.floatingParent.css({\n          position: 'absolute',\n          top: position.tfootTop - position.theadHeight,\n          left: position.left + 'px'\n        });\n        importantWidth(position.width);\n      } else if (mode === 'above') {\n        // only used for the footer\n        // Fix the position of the floating footer at top of the table body\n        this._clone(item, forceChange);\n\n        itemDom.floating.addClass('fixedHeader-locked');\n        itemDom.floatingParent.css({\n          position: 'absolute',\n          top: position.tbodyTop,\n          left: position.left + 'px'\n        });\n        importantWidth(position.width);\n      } // Restore focus if it was lost\n\n\n      if (focus && focus !== document.activeElement) {\n        setTimeout(function () {\n          focus.focus();\n        }, 10);\n      }\n\n      this.s.scrollLeft.header = -1;\n      this.s.scrollLeft.footer = -1;\n      this.s[item + 'Mode'] = mode;\n    },\n\n    /**\n     * Cache the positional information that is required for the mode\n     * calculations that FixedHeader performs.\n     *\n     * @private\n     */\n    _positions: function _positions() {\n      var dt = this.s.dt;\n      var table = dt.table();\n      var position = this.s.position;\n      var dom = this.dom;\n      var tableNode = $(table.node());\n\n      var scrollEnabled = this._scrollEnabled(); // Need to use the header and footer that are in the main table,\n      // regardless of if they are clones, since they hold the positions we\n      // want to measure from\n\n\n      var thead = $(dt.table().header());\n      var tfoot = $(dt.table().footer());\n      var tbody = dom.tbody;\n      var scrollBody = tableNode.parent();\n      position.visible = tableNode.is(':visible');\n      position.width = tableNode.outerWidth();\n      position.left = tableNode.offset().left;\n      position.theadTop = thead.offset().top;\n      position.tbodyTop = scrollEnabled ? scrollBody.offset().top : tbody.offset().top;\n      position.tbodyHeight = scrollEnabled ? scrollBody.outerHeight() : tbody.outerHeight();\n      position.theadHeight = thead.outerHeight();\n      position.theadBottom = position.theadTop + position.theadHeight;\n\n      if (tfoot.length) {\n        position.tfootTop = position.tbodyTop + position.tbodyHeight; //tfoot.offset().top;\n\n        position.tfootBottom = position.tfootTop + tfoot.outerHeight();\n        position.tfootHeight = tfoot.outerHeight();\n      } else {\n        position.tfootTop = position.tbodyTop + tbody.outerHeight();\n        position.tfootBottom = position.tfootTop;\n        position.tfootHeight = position.tfootTop;\n      }\n    },\n\n    /**\n     * Mode calculation - determine what mode the fixed items should be placed\n     * into.\n     *\n     * @param  {boolean} forceChange Force a redraw of the mode, even if already\n     *     in that mode.\n     * @private\n     */\n    _scroll: function _scroll(forceChange) {\n      if (this.s.dt.settings()[0].bDestroying) {\n        return;\n      } // ScrollBody details\n\n\n      var scrollEnabled = this._scrollEnabled();\n\n      var scrollBody = $(this.s.dt.table().node()).parent();\n      var scrollOffset = scrollBody.offset();\n      var scrollHeight = scrollBody.outerHeight(); // Window details\n\n      var windowLeft = $(document).scrollLeft();\n      var windowTop = $(document).scrollTop();\n      var windowHeight = $(window).height();\n      var windowBottom = windowHeight + windowTop;\n      var position = this.s.position;\n      var headerMode, footerMode; // Body Details\n\n      var bodyTop = scrollEnabled ? scrollOffset.top : position.tbodyTop;\n      var bodyLeft = scrollEnabled ? scrollOffset.left : position.left;\n      var bodyBottom = scrollEnabled ? scrollOffset.top + scrollHeight : position.tfootTop;\n      var bodyWidth = scrollEnabled ? scrollBody.outerWidth() : position.tbodyWidth;\n      var windowBottom = windowTop + windowHeight;\n\n      if (this.c.header) {\n        if (!this.s.enable) {\n          headerMode = 'in-place';\n        } // The header is in it's normal place if the body top is lower than\n        //  the scroll of the window plus the headerOffset and the height of the header\n        else if (!position.visible || windowTop + this.c.headerOffset + position.theadHeight <= bodyTop) {\n          headerMode = 'in-place';\n        } // The header should be floated if\n        else if ( // The scrolling plus the header offset plus the height of the header is lower than the top of the body\n        windowTop + this.c.headerOffset + position.theadHeight > bodyTop && // And the scrolling at the top plus the header offset is above the bottom of the body\n        windowTop + this.c.headerOffset < bodyBottom) {\n          headerMode = 'in';\n          var scrollBody = $($(this.s.dt.table().node()).parent()); // Further to the above, If the scrolling plus the header offset plus the header height is lower\n          // than the bottom of the table a shuffle is required so have to force the calculation\n\n          if (windowTop + this.c.headerOffset + position.theadHeight > bodyBottom || this.dom.header.floatingParent === undefined) {\n            forceChange = true;\n          } else {\n            this.dom.header.floatingParent.css({\n              'top': this.c.headerOffset,\n              'position': 'fixed'\n            }).append(this.dom.header.floating);\n          }\n        } // Anything else and the view is below the table\n        else {\n          headerMode = 'below';\n        }\n\n        if (forceChange || headerMode !== this.s.headerMode) {\n          this._modeChange(headerMode, 'header', forceChange);\n        }\n\n        this._horizontal('header', windowLeft);\n      }\n\n      var header = {\n        offset: {\n          top: 0,\n          left: 0\n        },\n        height: 0\n      };\n      var footer = {\n        offset: {\n          top: 0,\n          left: 0\n        },\n        height: 0\n      };\n\n      if (this.c.footer && this.dom.tfoot.length) {\n        if (!this.s.enable) {\n          footerMode = 'in-place';\n        } else if (!position.visible || position.tfootBottom + this.c.footerOffset <= windowBottom) {\n          footerMode = 'in-place';\n        } else if (bodyBottom + position.tfootHeight + this.c.footerOffset > windowBottom && bodyTop + this.c.footerOffset < windowBottom) {\n          footerMode = 'in';\n          forceChange = true;\n        } else {\n          footerMode = 'above';\n        }\n\n        if (forceChange || footerMode !== this.s.footerMode) {\n          this._modeChange(footerMode, 'footer', forceChange);\n        }\n\n        this._horizontal('footer', windowLeft);\n\n        var getOffsetHeight = function getOffsetHeight(el) {\n          return {\n            offset: el.offset(),\n            height: el.outerHeight()\n          };\n        };\n\n        header = this.dom.header.floating ? getOffsetHeight(this.dom.header.floating) : getOffsetHeight(this.dom.thead);\n        footer = this.dom.footer.floating ? getOffsetHeight(this.dom.footer.floating) : getOffsetHeight(this.dom.tfoot); // If scrolling is enabled and the footer is off the screen\n\n        if (scrollEnabled && footer.offset.top > windowTop) {\n          // && footer.offset.top >= windowBottom) {\n          // Calculate the gap between the top of the scrollBody and the top of the window\n          var overlap = windowTop - scrollOffset.top; // The new height is the bottom of the window\n\n          var newHeight = windowBottom + ( // If the gap between the top of the scrollbody and the window is more than\n          //  the height of the header then the top of the table is still visible so add that gap\n          // Doing this has effectively calculated the height from the top of the table to the bottom of the current page\n          overlap > -header.height ? overlap : 0) - ( // Take from that\n          // The top of the header plus\n          header.offset.top + ( // The header height if the standard header is present\n          overlap < -header.height ? header.height : 0) + // And the height of the footer\n          footer.height); // Don't want a negative height\n\n          if (newHeight < 0) {\n            newHeight = 0;\n          } // At the end of the above calculation the space between the header (top of the page if floating)\n          // and the point just above the footer should be the new value for the height of the table.\n\n\n          scrollBody.outerHeight(newHeight); // Need some rounding here as sometimes very small decimal places are encountered\n          // If the actual height is bigger or equal to the height we just applied then the footer is \"Floating\"\n\n          if (Math.round(scrollBody.outerHeight()) >= Math.round(newHeight)) {\n            $(this.dom.tfoot.parent()).addClass(\"fixedHeader-floating\");\n          } // Otherwise max-width has kicked in so it is not floating\n          else {\n            $(this.dom.tfoot.parent()).removeClass(\"fixedHeader-floating\");\n          }\n        }\n      }\n\n      if (this.dom.header.floating) {\n        this.dom.header.floatingParent.css('left', bodyLeft - windowLeft);\n      }\n\n      if (this.dom.footer.floating) {\n        this.dom.footer.floatingParent.css('left', bodyLeft - windowLeft);\n      } // If fixed columns is being used on this table then the blockers need to be copied across\n      // Cloning these is cleaner than creating as our own as it will keep consistency with fixedColumns automatically\n      // ASSUMING that the class remains the same\n\n\n      if (this.s.dt.settings()[0]._fixedColumns !== undefined) {\n        var adjustBlocker = function adjustBlocker(side, end, el) {\n          if (el === undefined) {\n            var blocker = $('div.dtfc-' + side + '-' + end + '-blocker');\n            el = blocker.length === 0 ? null : blocker.clone().appendTo('body').css('z-index', 1);\n          }\n\n          if (el !== null) {\n            el.css({\n              top: end === 'top' ? header.offset.top : footer.offset.top,\n              left: side === 'right' ? bodyLeft + bodyWidth - el.width() : bodyLeft\n            });\n          }\n\n          return el;\n        }; // Adjust all blockers\n\n\n        this.dom.header.rightBlocker = adjustBlocker('right', 'top', this.dom.header.rightBlocker);\n        this.dom.header.leftBlocker = adjustBlocker('left', 'top', this.dom.header.leftBlocker);\n        this.dom.footer.rightBlocker = adjustBlocker('right', 'bottom', this.dom.footer.rightBlocker);\n        this.dom.footer.leftBlocker = adjustBlocker('left', 'bottom', this.dom.footer.leftBlocker);\n      }\n    },\n\n    /**\n     * Function to check if scrolling is enabled on the table or not\n     * @returns Boolean value indicating if scrolling on the table is enabled or not\n     */\n    _scrollEnabled: function _scrollEnabled() {\n      var oScroll = this.s.dt.settings()[0].oScroll;\n\n      if (oScroll.sY !== \"\" || oScroll.sX !== \"\") {\n        return true;\n      }\n\n      return false;\n    }\n  });\n  /**\n   * Version\n   * @type {String}\n   * @static\n   */\n\n  FixedHeader.version = \"3.2.2\";\n  /**\n   * Defaults\n   * @type {Object}\n   * @static\n   */\n\n  FixedHeader.defaults = {\n    header: true,\n    footer: false,\n    headerOffset: 0,\n    footerOffset: 0\n  };\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * DataTables interfaces\n   */\n  // Attach for constructor access\n\n  $.fn.dataTable.FixedHeader = FixedHeader;\n  $.fn.DataTable.FixedHeader = FixedHeader; // DataTables creation - check if the FixedHeader option has been defined on the\n  // table and if so, initialise\n\n  $(document).on('init.dt.dtfh', function (e, settings, json) {\n    if (e.namespace !== 'dt') {\n      return;\n    }\n\n    var init = settings.oInit.fixedHeader;\n    var defaults = DataTable.defaults.fixedHeader;\n\n    if ((init || defaults) && !settings._fixedHeader) {\n      var opts = $.extend({}, defaults, init);\n\n      if (init !== false) {\n        new FixedHeader(settings, opts);\n      }\n    }\n  }); // DataTables API methods\n\n  DataTable.Api.register('fixedHeader()', function () {});\n  DataTable.Api.register('fixedHeader.adjust()', function () {\n    return this.iterator('table', function (ctx) {\n      var fh = ctx._fixedHeader;\n\n      if (fh) {\n        fh.update();\n      }\n    });\n  });\n  DataTable.Api.register('fixedHeader.enable()', function (flag) {\n    return this.iterator('table', function (ctx) {\n      var fh = ctx._fixedHeader;\n      flag = flag !== undefined ? flag : true;\n\n      if (fh && flag !== fh.enabled()) {\n        fh.enable(flag);\n      }\n    });\n  });\n  DataTable.Api.register('fixedHeader.enabled()', function () {\n    if (this.context.length) {\n      var fh = this.context[0]._fixedHeader;\n\n      if (fh) {\n        return fh.enabled();\n      }\n    }\n\n    return false;\n  });\n  DataTable.Api.register('fixedHeader.disable()', function () {\n    return this.iterator('table', function (ctx) {\n      var fh = ctx._fixedHeader;\n\n      if (fh && fh.enabled()) {\n        fh.enable(false);\n      }\n    });\n  });\n  $.each(['header', 'footer'], function (i, el) {\n    DataTable.Api.register('fixedHeader.' + el + 'Offset()', function (offset) {\n      var ctx = this.context;\n\n      if (offset === undefined) {\n        return ctx.length && ctx[0]._fixedHeader ? ctx[0]._fixedHeader[el + 'Offset']() : undefined;\n      }\n\n      return this.iterator('table', function (ctx) {\n        var fh = ctx._fixedHeader;\n\n        if (fh) {\n          fh[el + 'Offset'](offset);\n        }\n      });\n    });\n  });\n  return FixedHeader;\n});","map":null,"metadata":{},"sourceType":"script"}