{"ast":null,"code":"/*! Buttons for DataTables 2.2.2\n * Â©2016-2022 SpryMedia Ltd - datatables.net/license\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery', 'datatables.net'], function ($) {\n      return factory($, window, document);\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = function (root, $) {\n      if (!root) {\n        root = window;\n      }\n\n      if (!$ || !$.fn.dataTable) {\n        $ = require('datatables.net')(root, $).$;\n      }\n\n      return factory($, root, root.document);\n    };\n  } else {\n    // Browser\n    factory(jQuery, window, document);\n  }\n})(function ($, window, document, undefined) {\n  'use strict';\n\n  var DataTable = $.fn.dataTable; // Used for namespacing events added to the document by each instance, so they\n  // can be removed on destroy\n\n  var _instCounter = 0; // Button namespacing counter for namespacing events on individual buttons\n\n  var _buttonCounter = 0;\n  var _dtButtons = DataTable.ext.buttons; // Allow for jQuery slim\n\n  function _fadeIn(el, duration, fn) {\n    if ($.fn.animate) {\n      el.stop().fadeIn(duration, fn);\n    } else {\n      el.css('display', 'block');\n\n      if (fn) {\n        fn.call(el);\n      }\n    }\n  }\n\n  function _fadeOut(el, duration, fn) {\n    if ($.fn.animate) {\n      el.stop().fadeOut(duration, fn);\n    } else {\n      el.css('display', 'none');\n\n      if (fn) {\n        fn.call(el);\n      }\n    }\n  }\n  /**\n   * [Buttons description]\n   * @param {[type]}\n   * @param {[type]}\n   */\n\n\n  var Buttons = function Buttons(dt, config) {\n    // If not created with a `new` keyword then we return a wrapper function that\n    // will take the settings object for a DT. This allows easy use of new instances\n    // with the `layout` option - e.g. `topLeft: $.fn.dataTable.Buttons( ... )`.\n    if (!(this instanceof Buttons)) {\n      return function (settings) {\n        return new Buttons(settings, dt).container();\n      };\n    } // If there is no config set it to an empty object\n\n\n    if (typeof config === 'undefined') {\n      config = {};\n    } // Allow a boolean true for defaults\n\n\n    if (config === true) {\n      config = {};\n    } // For easy configuration of buttons an array can be given\n\n\n    if (Array.isArray(config)) {\n      config = {\n        buttons: config\n      };\n    }\n\n    this.c = $.extend(true, {}, Buttons.defaults, config); // Don't want a deep copy for the buttons\n\n    if (config.buttons) {\n      this.c.buttons = config.buttons;\n    }\n\n    this.s = {\n      dt: new DataTable.Api(dt),\n      buttons: [],\n      listenKeys: '',\n      namespace: 'dtb' + _instCounter++\n    };\n    this.dom = {\n      container: $('<' + this.c.dom.container.tag + '/>').addClass(this.c.dom.container.className)\n    };\n\n    this._constructor();\n  };\n\n  $.extend(Buttons.prototype, {\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Public methods\n     */\n\n    /**\n     * Get the action of a button\n     * @param  {int|string} Button index\n     * @return {function}\n     */\n\n    /**\n    * Set the action of a button\n    * @param  {node} node Button element\n    * @param  {function} action Function to set\n    * @return {Buttons} Self for chaining\n    */\n    action: function action(node, _action) {\n      var button = this._nodeToButton(node);\n\n      if (_action === undefined) {\n        return button.conf.action;\n      }\n\n      button.conf.action = _action;\n      return this;\n    },\n\n    /**\n     * Add an active class to the button to make to look active or get current\n     * active state.\n     * @param  {node} node Button element\n     * @param  {boolean} [flag] Enable / disable flag\n     * @return {Buttons} Self for chaining or boolean for getter\n     */\n    active: function active(node, flag) {\n      var button = this._nodeToButton(node);\n\n      var klass = this.c.dom.button.active;\n      var jqNode = $(button.node);\n\n      if (flag === undefined) {\n        return jqNode.hasClass(klass);\n      }\n\n      jqNode.toggleClass(klass, flag === undefined ? true : flag);\n      return this;\n    },\n\n    /**\n     * Add a new button\n     * @param {object} config Button configuration object, base string name or function\n     * @param {int|string} [idx] Button index for where to insert the button\n     * @param {boolean} [draw=true] Trigger a draw. Set a false when adding\n     *   lots of buttons, until the last button.\n     * @return {Buttons} Self for chaining\n     */\n    add: function add(config, idx, draw) {\n      var buttons = this.s.buttons;\n\n      if (typeof idx === 'string') {\n        var split = idx.split('-');\n        var base = this.s;\n\n        for (var i = 0, ien = split.length - 1; i < ien; i++) {\n          base = base.buttons[split[i] * 1];\n        }\n\n        buttons = base.buttons;\n        idx = split[split.length - 1] * 1;\n      }\n\n      this._expandButton(buttons, config, config !== undefined ? config.split : undefined, (config === undefined || config.split === undefined || config.split.length === 0) && base !== undefined, false, idx);\n\n      if (draw === undefined || draw === true) {\n        this._draw();\n      }\n\n      return this;\n    },\n\n    /**\n     * Clear buttons from a collection and then insert new buttons\n     */\n    collectionRebuild: function collectionRebuild(node, newButtons) {\n      var button = this._nodeToButton(node);\n\n      if (newButtons !== undefined) {\n        var i; // Need to reverse the array\n\n        for (i = button.buttons.length - 1; i >= 0; i--) {\n          this.remove(button.buttons[i].node);\n        }\n\n        for (i = 0; i < newButtons.length; i++) {\n          var newBtn = newButtons[i];\n\n          this._expandButton(button.buttons, newBtn, newBtn !== undefined && newBtn.config !== undefined && newBtn.config.split !== undefined, true, newBtn.parentConf !== undefined && newBtn.parentConf.split !== undefined, i, newBtn.parentConf);\n        }\n      }\n\n      this._draw(button.collection, button.buttons);\n    },\n\n    /**\n     * Get the container node for the buttons\n     * @return {jQuery} Buttons node\n     */\n    container: function container() {\n      return this.dom.container;\n    },\n\n    /**\n     * Disable a button\n     * @param  {node} node Button node\n     * @return {Buttons} Self for chaining\n     */\n    disable: function disable(node) {\n      var button = this._nodeToButton(node);\n\n      $(button.node).addClass(this.c.dom.button.disabled).attr('disabled', true);\n      return this;\n    },\n\n    /**\n     * Destroy the instance, cleaning up event handlers and removing DOM\n     * elements\n     * @return {Buttons} Self for chaining\n     */\n    destroy: function destroy() {\n      // Key event listener\n      $('body').off('keyup.' + this.s.namespace); // Individual button destroy (so they can remove their own events if\n      // needed). Take a copy as the array is modified by `remove`\n\n      var buttons = this.s.buttons.slice();\n      var i, ien;\n\n      for (i = 0, ien = buttons.length; i < ien; i++) {\n        this.remove(buttons[i].node);\n      } // Container\n\n\n      this.dom.container.remove(); // Remove from the settings object collection\n\n      var buttonInsts = this.s.dt.settings()[0];\n\n      for (i = 0, ien = buttonInsts.length; i < ien; i++) {\n        if (buttonInsts.inst === this) {\n          buttonInsts.splice(i, 1);\n          break;\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Enable / disable a button\n     * @param  {node} node Button node\n     * @param  {boolean} [flag=true] Enable / disable flag\n     * @return {Buttons} Self for chaining\n     */\n    enable: function enable(node, flag) {\n      if (flag === false) {\n        return this.disable(node);\n      }\n\n      var button = this._nodeToButton(node);\n\n      $(button.node).removeClass(this.c.dom.button.disabled).removeAttr('disabled');\n      return this;\n    },\n\n    /**\n     * Get a button's index\n     * \n     * This is internally recursive\n     * @param {element} node Button to get the index of\n     * @return {string} Button index\n     */\n    index: function index(node, nested, buttons) {\n      if (!nested) {\n        nested = '';\n        buttons = this.s.buttons;\n      }\n\n      for (var i = 0, ien = buttons.length; i < ien; i++) {\n        var inner = buttons[i].buttons;\n\n        if (buttons[i].node === node) {\n          return nested + i;\n        }\n\n        if (inner && inner.length) {\n          var match = this.index(node, i + '-', inner);\n\n          if (match !== null) {\n            return match;\n          }\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Get the instance name for the button set selector\n     * @return {string} Instance name\n     */\n    name: function name() {\n      return this.c.name;\n    },\n\n    /**\n     * Get a button's node of the buttons container if no button is given\n     * @param  {node} [node] Button node\n     * @return {jQuery} Button element, or container\n     */\n    node: function node(_node) {\n      if (!_node) {\n        return this.dom.container;\n      }\n\n      var button = this._nodeToButton(_node);\n\n      return $(button.node);\n    },\n\n    /**\n     * Set / get a processing class on the selected button\n     * @param {element} node Triggering button node\n     * @param  {boolean} flag true to add, false to remove, undefined to get\n     * @return {boolean|Buttons} Getter value or this if a setter.\n     */\n    processing: function processing(node, flag) {\n      var dt = this.s.dt;\n\n      var button = this._nodeToButton(node);\n\n      if (flag === undefined) {\n        return $(button.node).hasClass('processing');\n      }\n\n      $(button.node).toggleClass('processing', flag);\n      $(dt.table().node()).triggerHandler('buttons-processing.dt', [flag, dt.button(node), dt, $(node), button.conf]);\n      return this;\n    },\n\n    /**\n     * Remove a button.\n     * @param  {node} node Button node\n     * @return {Buttons} Self for chaining\n     */\n    remove: function remove(node) {\n      var button = this._nodeToButton(node);\n\n      var host = this._nodeToHost(node);\n\n      var dt = this.s.dt; // Remove any child buttons first\n\n      if (button.buttons.length) {\n        for (var i = button.buttons.length - 1; i >= 0; i--) {\n          this.remove(button.buttons[i].node);\n        }\n      }\n\n      button.conf.destroying = true; // Allow the button to remove event handlers, etc\n\n      if (button.conf.destroy) {\n        button.conf.destroy.call(dt.button(node), dt, $(node), button.conf);\n      }\n\n      this._removeKey(button.conf);\n\n      $(button.node).remove();\n      var idx = $.inArray(button, host);\n      host.splice(idx, 1);\n      return this;\n    },\n\n    /**\n     * Get the text for a button\n     * @param  {int|string} node Button index\n     * @return {string} Button text\n     */\n\n    /**\n    * Set the text for a button\n    * @param  {int|string|function} node Button index\n    * @param  {string} label Text\n    * @return {Buttons} Self for chaining\n    */\n    text: function text(node, label) {\n      var button = this._nodeToButton(node);\n\n      var buttonLiner = this.c.dom.collection.buttonLiner;\n      var linerTag = button.inCollection && buttonLiner && buttonLiner.tag ? buttonLiner.tag : this.c.dom.buttonLiner.tag;\n      var dt = this.s.dt;\n      var jqNode = $(button.node);\n\n      var text = function text(opt) {\n        return typeof opt === 'function' ? opt(dt, jqNode, button.conf) : opt;\n      };\n\n      if (label === undefined) {\n        return text(button.conf.text);\n      }\n\n      button.conf.text = label;\n\n      if (linerTag) {\n        jqNode.children(linerTag).eq(0).filter(':not(.dt-down-arrow)').html(text(label));\n      } else {\n        jqNode.html(text(label));\n      }\n\n      return this;\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Constructor\n     */\n\n    /**\n     * Buttons constructor\n     * @private\n     */\n    _constructor: function _constructor() {\n      var that = this;\n      var dt = this.s.dt;\n      var dtSettings = dt.settings()[0];\n      var buttons = this.c.buttons;\n\n      if (!dtSettings._buttons) {\n        dtSettings._buttons = [];\n      }\n\n      dtSettings._buttons.push({\n        inst: this,\n        name: this.c.name\n      });\n\n      for (var i = 0, ien = buttons.length; i < ien; i++) {\n        this.add(buttons[i]);\n      }\n\n      dt.on('destroy', function (e, settings) {\n        if (settings === dtSettings) {\n          that.destroy();\n        }\n      }); // Global key event binding to listen for button keys\n\n      $('body').on('keyup.' + this.s.namespace, function (e) {\n        if (!document.activeElement || document.activeElement === document.body) {\n          // SUse a string of characters for fast lookup of if we need to\n          // handle this\n          var character = String.fromCharCode(e.keyCode).toLowerCase();\n\n          if (that.s.listenKeys.toLowerCase().indexOf(character) !== -1) {\n            that._keypress(character, e);\n          }\n        }\n      });\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Private methods\n     */\n\n    /**\n     * Add a new button to the key press listener\n     * @param {object} conf Resolved button configuration object\n     * @private\n     */\n    _addKey: function _addKey(conf) {\n      if (conf.key) {\n        this.s.listenKeys += $.isPlainObject(conf.key) ? conf.key.key : conf.key;\n      }\n    },\n\n    /**\n     * Insert the buttons into the container. Call without parameters!\n     * @param  {node} [container] Recursive only - Insert point\n     * @param  {array} [buttons] Recursive only - Buttons array\n     * @private\n     */\n    _draw: function _draw(container, buttons) {\n      if (!container) {\n        container = this.dom.container;\n        buttons = this.s.buttons;\n      }\n\n      container.children().detach();\n\n      for (var i = 0, ien = buttons.length; i < ien; i++) {\n        container.append(buttons[i].inserter);\n        container.append(' ');\n\n        if (buttons[i].buttons && buttons[i].buttons.length) {\n          this._draw(buttons[i].collection, buttons[i].buttons);\n        }\n      }\n    },\n\n    /**\n     * Create buttons from an array of buttons\n     * @param  {array} attachTo Buttons array to attach to\n     * @param  {object} button Button definition\n     * @param  {boolean} inCollection true if the button is in a collection\n     * @private\n     */\n    _expandButton: function _expandButton(attachTo, button, split, inCollection, inSplit, attachPoint, parentConf) {\n      var dt = this.s.dt;\n      var buttonCounter = 0;\n      var isSplit = false;\n      var buttons = !Array.isArray(button) ? [button] : button;\n\n      if (button === undefined) {\n        buttons = !Array.isArray(split) ? [split] : split;\n      }\n\n      if (button !== undefined && button.split !== undefined) {\n        isSplit = true;\n      }\n\n      for (var i = 0, ien = buttons.length; i < ien; i++) {\n        var conf = this._resolveExtends(buttons[i]);\n\n        if (!conf) {\n          continue;\n        }\n\n        if (conf.config !== undefined && conf.config.split) {\n          isSplit = true;\n        } else {\n          isSplit = false;\n        } // If the configuration is an array, then expand the buttons at this\n        // point\n\n\n        if (Array.isArray(conf)) {\n          this._expandButton(attachTo, conf, built !== undefined && built.conf !== undefined ? built.conf.split : undefined, inCollection, parentConf !== undefined && parentConf.split !== undefined, attachPoint, parentConf);\n\n          continue;\n        }\n\n        var built = this._buildButton(conf, inCollection, conf.split !== undefined || conf.config !== undefined && conf.config.split !== undefined, inSplit);\n\n        if (!built) {\n          continue;\n        }\n\n        if (attachPoint !== undefined && attachPoint !== null) {\n          attachTo.splice(attachPoint, 0, built);\n          attachPoint++;\n        } else {\n          attachTo.push(built);\n        }\n\n        if (built.conf.buttons || built.conf.split) {\n          built.collection = $('<' + (isSplit ? this.c.dom.splitCollection.tag : this.c.dom.collection.tag) + '/>');\n          built.conf._collection = built.collection;\n\n          if (built.conf.split) {\n            for (var j = 0; j < built.conf.split.length; j++) {\n              if (typeof built.conf.split[j] === \"object\") {\n                built.conf.split[j].parent = parentConf;\n\n                if (built.conf.split[j].collectionLayout === undefined) {\n                  built.conf.split[j].collectionLayout = built.conf.collectionLayout;\n                }\n\n                if (built.conf.split[j].dropup === undefined) {\n                  built.conf.split[j].dropup = built.conf.dropup;\n                }\n\n                if (built.conf.split[j].fade === undefined) {\n                  built.conf.split[j].fade = built.conf.fade;\n                }\n              }\n            }\n          } else {\n            $(built.node).append($('<span class=\"dt-down-arrow\">' + this.c.dom.splitDropdown.text + '</span>'));\n          }\n\n          this._expandButton(built.buttons, built.conf.buttons, built.conf.split, !isSplit, isSplit, attachPoint, built.conf);\n        }\n\n        built.conf.parent = parentConf; // init call is made here, rather than buildButton as it needs to\n        // be selectable, and for that it needs to be in the buttons array\n\n        if (conf.init) {\n          conf.init.call(dt.button(built.node), dt, $(built.node), conf);\n        }\n\n        buttonCounter++;\n      }\n    },\n\n    /**\n     * Create an individual button\n     * @param  {object} config            Resolved button configuration\n     * @param  {boolean} inCollection `true` if a collection button\n     * @return {jQuery} Created button node (jQuery)\n     * @private\n     */\n    _buildButton: function _buildButton(config, inCollection, isSplit, inSplit) {\n      var buttonDom = this.c.dom.button;\n      var linerDom = this.c.dom.buttonLiner;\n      var collectionDom = this.c.dom.collection;\n      var splitDom = this.c.dom.split;\n      var splitCollectionDom = this.c.dom.splitCollection;\n      var splitDropdownButton = this.c.dom.splitDropdownButton;\n      var dt = this.s.dt;\n\n      var text = function text(opt) {\n        return typeof opt === 'function' ? opt(dt, button, config) : opt;\n      }; // Spacers don't do much other than insert an element into the DOM\n\n\n      if (config.spacer) {\n        var spacer = $('<span></span>').addClass('dt-button-spacer ' + config.style + ' ' + buttonDom.spacerClass).html(text(config.text));\n        return {\n          conf: config,\n          node: spacer,\n          inserter: spacer,\n          buttons: [],\n          inCollection: inCollection,\n          isSplit: isSplit,\n          inSplit: inSplit,\n          collection: null\n        };\n      }\n\n      if (!isSplit && inSplit && splitCollectionDom) {\n        buttonDom = splitDropdownButton;\n      } else if (!isSplit && inCollection && collectionDom.button) {\n        buttonDom = collectionDom.button;\n      }\n\n      if (!isSplit && inSplit && splitCollectionDom.buttonLiner) {\n        linerDom = splitCollectionDom.buttonLiner;\n      } else if (!isSplit && inCollection && collectionDom.buttonLiner) {\n        linerDom = collectionDom.buttonLiner;\n      } // Make sure that the button is available based on whatever requirements\n      // it has. For example, PDF button require pdfmake\n\n\n      if (config.available && !config.available(dt, config) && !config.hasOwnProperty('html')) {\n        return false;\n      }\n\n      var button;\n\n      if (!config.hasOwnProperty('html')) {\n        var action = function action(e, dt, button, config) {\n          config.action.call(dt.button(button), e, dt, button, config);\n          $(dt.table().node()).triggerHandler('buttons-action.dt', [dt.button(button), dt, button, config]);\n        };\n\n        var tag = config.tag || buttonDom.tag;\n        var clickBlurs = config.clickBlurs === undefined ? true : config.clickBlurs;\n        button = $('<' + tag + '/>').addClass(buttonDom.className).addClass(inSplit ? this.c.dom.splitDropdownButton.className : '').attr('tabindex', this.s.dt.settings()[0].iTabIndex).attr('aria-controls', this.s.dt.table().node().id).on('click.dtb', function (e) {\n          e.preventDefault();\n\n          if (!button.hasClass(buttonDom.disabled) && config.action) {\n            action(e, dt, button, config);\n          }\n\n          if (clickBlurs) {\n            button.trigger('blur');\n          }\n        }).on('keypress.dtb', function (e) {\n          if (e.keyCode === 13) {\n            e.preventDefault();\n\n            if (!button.hasClass(buttonDom.disabled) && config.action) {\n              action(e, dt, button, config);\n            }\n          }\n        }); // Make `a` tags act like a link\n\n        if (tag.toLowerCase() === 'a') {\n          button.attr('href', '#');\n        } // Button tags should have `type=button` so they don't have any default behaviour\n\n\n        if (tag.toLowerCase() === 'button') {\n          button.attr('type', 'button');\n        }\n\n        if (linerDom.tag) {\n          var liner = $('<' + linerDom.tag + '/>').html(text(config.text)).addClass(linerDom.className);\n\n          if (linerDom.tag.toLowerCase() === 'a') {\n            liner.attr('href', '#');\n          }\n\n          button.append(liner);\n        } else {\n          button.html(text(config.text));\n        }\n\n        if (config.enabled === false) {\n          button.addClass(buttonDom.disabled);\n        }\n\n        if (config.className) {\n          button.addClass(config.className);\n        }\n\n        if (config.titleAttr) {\n          button.attr('title', text(config.titleAttr));\n        }\n\n        if (config.attr) {\n          button.attr(config.attr);\n        }\n\n        if (!config.namespace) {\n          config.namespace = '.dt-button-' + _buttonCounter++;\n        }\n\n        if (config.config !== undefined && config.config.split) {\n          config.split = config.config.split;\n        }\n      } else {\n        button = $(config.html);\n      }\n\n      var buttonContainer = this.c.dom.buttonContainer;\n      var inserter;\n\n      if (buttonContainer && buttonContainer.tag) {\n        inserter = $('<' + buttonContainer.tag + '/>').addClass(buttonContainer.className).append(button);\n      } else {\n        inserter = button;\n      }\n\n      this._addKey(config); // Style integration callback for DOM manipulation\n      // Note that this is _not_ documented. It is currently\n      // for style integration only\n\n\n      if (this.c.buttonCreated) {\n        inserter = this.c.buttonCreated(config, inserter);\n      }\n\n      var splitDiv;\n\n      if (isSplit) {\n        splitDiv = $('<div/>').addClass(this.c.dom.splitWrapper.className);\n        splitDiv.append(button);\n        var dropButtonConfig = $.extend(config, {\n          text: this.c.dom.splitDropdown.text,\n          className: this.c.dom.splitDropdown.className,\n          closeButton: false,\n          attr: {\n            'aria-haspopup': true,\n            'aria-expanded': false\n          },\n          align: this.c.dom.splitDropdown.align,\n          splitAlignClass: this.c.dom.splitDropdown.splitAlignClass\n        });\n\n        this._addKey(dropButtonConfig);\n\n        var splitAction = function splitAction(e, dt, button, config) {\n          _dtButtons.split.action.call(dt.button($('div.dt-btn-split-wrapper')[0]), e, dt, button, config);\n\n          $(dt.table().node()).triggerHandler('buttons-action.dt', [dt.button(button), dt, button, config]);\n          button.attr('aria-expanded', true);\n        };\n\n        var dropButton = $('<button class=\"' + this.c.dom.splitDropdown.className + ' dt-button\"><span class=\"dt-btn-split-drop-arrow\">' + this.c.dom.splitDropdown.text + '</span></button>').on('click.dtb', function (e) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          if (!dropButton.hasClass(buttonDom.disabled)) {\n            splitAction(e, dt, dropButton, dropButtonConfig);\n          }\n\n          if (clickBlurs) {\n            dropButton.trigger('blur');\n          }\n        }).on('keypress.dtb', function (e) {\n          if (e.keyCode === 13) {\n            e.preventDefault();\n\n            if (!dropButton.hasClass(buttonDom.disabled)) {\n              splitAction(e, dt, dropButton, dropButtonConfig);\n            }\n          }\n        });\n\n        if (config.split.length === 0) {\n          dropButton.addClass('dtb-hide-drop');\n        }\n\n        splitDiv.append(dropButton).attr(dropButtonConfig.attr);\n      }\n\n      return {\n        conf: config,\n        node: isSplit ? splitDiv.get(0) : button.get(0),\n        inserter: isSplit ? splitDiv : inserter,\n        buttons: [],\n        inCollection: inCollection,\n        isSplit: isSplit,\n        inSplit: inSplit,\n        collection: null\n      };\n    },\n\n    /**\n     * Get the button object from a node (recursive)\n     * @param  {node} node Button node\n     * @param  {array} [buttons] Button array, uses base if not defined\n     * @return {object} Button object\n     * @private\n     */\n    _nodeToButton: function _nodeToButton(node, buttons) {\n      if (!buttons) {\n        buttons = this.s.buttons;\n      }\n\n      for (var i = 0, ien = buttons.length; i < ien; i++) {\n        if (buttons[i].node === node) {\n          return buttons[i];\n        }\n\n        if (buttons[i].buttons.length) {\n          var ret = this._nodeToButton(node, buttons[i].buttons);\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n\n    /**\n     * Get container array for a button from a button node (recursive)\n     * @param  {node} node Button node\n     * @param  {array} [buttons] Button array, uses base if not defined\n     * @return {array} Button's host array\n     * @private\n     */\n    _nodeToHost: function _nodeToHost(node, buttons) {\n      if (!buttons) {\n        buttons = this.s.buttons;\n      }\n\n      for (var i = 0, ien = buttons.length; i < ien; i++) {\n        if (buttons[i].node === node) {\n          return buttons;\n        }\n\n        if (buttons[i].buttons.length) {\n          var ret = this._nodeToHost(node, buttons[i].buttons);\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n\n    /**\n     * Handle a key press - determine if any button's key configured matches\n     * what was typed and trigger the action if so.\n     * @param  {string} character The character pressed\n     * @param  {object} e Key event that triggered this call\n     * @private\n     */\n    _keypress: function _keypress(character, e) {\n      // Check if this button press already activated on another instance of Buttons\n      if (e._buttonsHandled) {\n        return;\n      }\n\n      var run = function run(conf, node) {\n        if (!conf.key) {\n          return;\n        }\n\n        if (conf.key === character) {\n          e._buttonsHandled = true;\n          $(node).click();\n        } else if ($.isPlainObject(conf.key)) {\n          if (conf.key.key !== character) {\n            return;\n          }\n\n          if (conf.key.shiftKey && !e.shiftKey) {\n            return;\n          }\n\n          if (conf.key.altKey && !e.altKey) {\n            return;\n          }\n\n          if (conf.key.ctrlKey && !e.ctrlKey) {\n            return;\n          }\n\n          if (conf.key.metaKey && !e.metaKey) {\n            return;\n          } // Made it this far - it is good\n\n\n          e._buttonsHandled = true;\n          $(node).click();\n        }\n      };\n\n      var recurse = function recurse(a) {\n        for (var i = 0, ien = a.length; i < ien; i++) {\n          run(a[i].conf, a[i].node);\n\n          if (a[i].buttons.length) {\n            recurse(a[i].buttons);\n          }\n        }\n      };\n\n      recurse(this.s.buttons);\n    },\n\n    /**\n     * Remove a key from the key listener for this instance (to be used when a\n     * button is removed)\n     * @param  {object} conf Button configuration\n     * @private\n     */\n    _removeKey: function _removeKey(conf) {\n      if (conf.key) {\n        var character = $.isPlainObject(conf.key) ? conf.key.key : conf.key; // Remove only one character, as multiple buttons could have the\n        // same listening key\n\n        var a = this.s.listenKeys.split('');\n        var idx = $.inArray(character, a);\n        a.splice(idx, 1);\n        this.s.listenKeys = a.join('');\n      }\n    },\n\n    /**\n     * Resolve a button configuration\n     * @param  {string|function|object} conf Button config to resolve\n     * @return {object} Button configuration\n     * @private\n     */\n    _resolveExtends: function _resolveExtends(conf) {\n      var that = this;\n      var dt = this.s.dt;\n      var i, ien;\n\n      var toConfObject = function toConfObject(base) {\n        var loop = 0; // Loop until we have resolved to a button configuration, or an\n        // array of button configurations (which will be iterated\n        // separately)\n\n        while (!$.isPlainObject(base) && !Array.isArray(base)) {\n          if (base === undefined) {\n            return;\n          }\n\n          if (typeof base === 'function') {\n            base = base.call(that, dt, conf);\n\n            if (!base) {\n              return false;\n            }\n          } else if (typeof base === 'string') {\n            if (!_dtButtons[base]) {\n              return {\n                html: base\n              };\n            }\n\n            base = _dtButtons[base];\n          }\n\n          loop++;\n\n          if (loop > 30) {\n            // Protect against misconfiguration killing the browser\n            throw 'Buttons: Too many iterations';\n          }\n        }\n\n        return Array.isArray(base) ? base : $.extend({}, base);\n      };\n\n      conf = toConfObject(conf);\n\n      while (conf && conf.extend) {\n        // Use `toConfObject` in case the button definition being extended\n        // is itself a string or a function\n        if (!_dtButtons[conf.extend]) {\n          throw 'Cannot extend unknown button type: ' + conf.extend;\n        }\n\n        var objArray = toConfObject(_dtButtons[conf.extend]);\n\n        if (Array.isArray(objArray)) {\n          return objArray;\n        } else if (!objArray) {\n          // This is a little brutal as it might be possible to have a\n          // valid button without the extend, but if there is no extend\n          // then the host button would be acting in an undefined state\n          return false;\n        } // Stash the current class name\n\n\n        var originalClassName = objArray.className;\n\n        if (conf.config !== undefined && objArray.config !== undefined) {\n          conf.config = $.extend({}, objArray.config, conf.config);\n        }\n\n        conf = $.extend({}, objArray, conf); // The extend will have overwritten the original class name if the\n        // `conf` object also assigned a class, but we want to concatenate\n        // them so they are list that is combined from all extended buttons\n\n        if (originalClassName && conf.className !== originalClassName) {\n          conf.className = originalClassName + ' ' + conf.className;\n        } // Buttons to be added to a collection  -gives the ability to define\n        // if buttons should be added to the start or end of a collection\n\n\n        var postfixButtons = conf.postfixButtons;\n\n        if (postfixButtons) {\n          if (!conf.buttons) {\n            conf.buttons = [];\n          }\n\n          for (i = 0, ien = postfixButtons.length; i < ien; i++) {\n            conf.buttons.push(postfixButtons[i]);\n          }\n\n          conf.postfixButtons = null;\n        }\n\n        var prefixButtons = conf.prefixButtons;\n\n        if (prefixButtons) {\n          if (!conf.buttons) {\n            conf.buttons = [];\n          }\n\n          for (i = 0, ien = prefixButtons.length; i < ien; i++) {\n            conf.buttons.splice(i, 0, prefixButtons[i]);\n          }\n\n          conf.prefixButtons = null;\n        } // Although we want the `conf` object to overwrite almost all of\n        // the properties of the object being extended, the `extend`\n        // property should come from the object being extended\n\n\n        conf.extend = objArray.extend;\n      }\n\n      return conf;\n    },\n\n    /**\n     * Display (and replace if there is an existing one) a popover attached to a button\n     * @param {string|node} content Content to show\n     * @param {DataTable.Api} hostButton DT API instance of the button\n     * @param {object} inOpts Options (see object below for all options)\n     */\n    _popover: function _popover(content, hostButton, inOpts, e) {\n      var dt = hostButton;\n      var buttonsSettings = this.c;\n      var closed = false;\n      var options = $.extend({\n        align: 'button-left',\n        // button-right, dt-container, split-left, split-right\n        autoClose: false,\n        background: true,\n        backgroundClassName: 'dt-button-background',\n        closeButton: true,\n        contentClassName: buttonsSettings.dom.collection.className,\n        collectionLayout: '',\n        collectionTitle: '',\n        dropup: false,\n        fade: 400,\n        popoverTitle: '',\n        rightAlignClassName: 'dt-button-right',\n        tag: buttonsSettings.dom.collection.tag\n      }, inOpts);\n      var hostNode = hostButton.node();\n\n      var close = function close() {\n        closed = true;\n\n        _fadeOut($('.dt-button-collection'), options.fade, function () {\n          $(this).detach();\n        });\n\n        $(dt.buttons('[aria-haspopup=\"true\"][aria-expanded=\"true\"]').nodes()).attr('aria-expanded', 'false');\n        $('div.dt-button-background').off('click.dtb-collection');\n        Buttons.background(false, options.backgroundClassName, options.fade, hostNode);\n        $(window).off('resize.resize.dtb-collection');\n        $('body').off('.dtb-collection');\n        dt.off('buttons-action.b-internal');\n        dt.off('destroy');\n      };\n\n      if (content === false) {\n        close();\n        return;\n      }\n\n      var existingExpanded = $(dt.buttons('[aria-haspopup=\"true\"][aria-expanded=\"true\"]').nodes());\n\n      if (existingExpanded.length) {\n        // Reuse the current position if the button that was triggered is inside an existing collection\n        if (hostNode.closest('div.dt-button-collection').length) {\n          hostNode = existingExpanded.eq(0);\n        }\n\n        close();\n      } // Try to be smart about the layout\n\n\n      var cnt = $('.dt-button', content).length;\n      var mod = '';\n\n      if (cnt === 3) {\n        mod = 'dtb-b3';\n      } else if (cnt === 2) {\n        mod = 'dtb-b2';\n      } else if (cnt === 1) {\n        mod = 'dtb-b1';\n      }\n\n      var display = $('<div/>').addClass('dt-button-collection').addClass(options.collectionLayout).addClass(options.splitAlignClass).addClass(mod).css('display', 'none');\n      content = $(content).addClass(options.contentClassName).attr('role', 'menu').appendTo(display);\n      hostNode.attr('aria-expanded', 'true');\n\n      if (hostNode.parents('body')[0] !== document.body) {\n        hostNode = document.body.lastChild;\n      }\n\n      if (options.popoverTitle) {\n        display.prepend('<div class=\"dt-button-collection-title\">' + options.popoverTitle + '</div>');\n      } else if (options.collectionTitle) {\n        display.prepend('<div class=\"dt-button-collection-title\">' + options.collectionTitle + '</div>');\n      }\n\n      if (options.closeButton) {\n        display.prepend('<div class=\"dtb-popover-close\">x</div>').addClass('dtb-collection-closeable');\n      }\n\n      _fadeIn(display.insertAfter(hostNode), options.fade);\n\n      var tableContainer = $(hostButton.table().container());\n      var position = display.css('position');\n\n      if (options.span === 'container' || options.align === 'dt-container') {\n        hostNode = hostNode.parent();\n        display.css('width', tableContainer.width());\n      } // Align the popover relative to the DataTables container\n      // Useful for wide popovers such as SearchPanes\n\n\n      if (position === 'absolute') {\n        // Align relative to the host button\n        var offsetParent = $(hostNode[0].offsetParent);\n        var buttonPosition = hostNode.position();\n        var buttonOffset = hostNode.offset();\n        var tableSizes = offsetParent.offset();\n        var containerPosition = offsetParent.position();\n        var computed = window.getComputedStyle(offsetParent[0]);\n        tableSizes.height = offsetParent.outerHeight();\n        tableSizes.width = offsetParent.width() + parseFloat(computed.paddingLeft);\n        tableSizes.right = tableSizes.left + tableSizes.width;\n        tableSizes.bottom = tableSizes.top + tableSizes.height; // Set the initial position so we can read height / width\n\n        var top = buttonPosition.top + hostNode.outerHeight();\n        var left = buttonPosition.left;\n        display.css({\n          top: top,\n          left: left\n        }); // Get the popover position\n\n        computed = window.getComputedStyle(display[0]);\n        var popoverSizes = display.offset();\n        popoverSizes.height = display.outerHeight();\n        popoverSizes.width = display.outerWidth();\n        popoverSizes.right = popoverSizes.left + popoverSizes.width;\n        popoverSizes.bottom = popoverSizes.top + popoverSizes.height;\n        popoverSizes.marginTop = parseFloat(computed.marginTop);\n        popoverSizes.marginBottom = parseFloat(computed.marginBottom); // First position per the class requirements - pop up and right align\n\n        if (options.dropup) {\n          top = buttonPosition.top - popoverSizes.height - popoverSizes.marginTop - popoverSizes.marginBottom;\n        }\n\n        if (options.align === 'button-right' || display.hasClass(options.rightAlignClassName)) {\n          left = buttonPosition.left - popoverSizes.width + hostNode.outerWidth();\n        } // Container alignment - make sure it doesn't overflow the table container\n\n\n        if (options.align === 'dt-container' || options.align === 'container') {\n          if (left < buttonPosition.left) {\n            left = -buttonPosition.left;\n          }\n\n          if (left + popoverSizes.width > tableSizes.width) {\n            left = tableSizes.width - popoverSizes.width;\n          }\n        } // Window adjustment\n\n\n        if (containerPosition.left + left + popoverSizes.width > $(window).width()) {\n          // Overflowing the document to the right\n          left = $(window).width() - popoverSizes.width - containerPosition.left;\n        }\n\n        if (buttonOffset.left + left < 0) {\n          // Off to the left of the document\n          left = -buttonOffset.left;\n        }\n\n        if (containerPosition.top + top + popoverSizes.height > $(window).height() + $(window).scrollTop()) {\n          // Pop up if otherwise we'd need the user to scroll down\n          top = buttonPosition.top - popoverSizes.height - popoverSizes.marginTop - popoverSizes.marginBottom;\n        }\n\n        if (containerPosition.top + top < $(window).scrollTop()) {\n          // Correction for when the top is beyond the top of the page\n          top = buttonPosition.top + hostNode.outerHeight();\n        } // Calculations all done - now set it\n\n\n        display.css({\n          top: top,\n          left: left\n        });\n      } else {\n        // Fix position - centre on screen\n        var position = function position() {\n          var half = $(window).height() / 2;\n          var top = display.height() / 2;\n\n          if (top > half) {\n            top = half;\n          }\n\n          display.css('marginTop', top * -1);\n        };\n\n        position();\n        $(window).on('resize.dtb-collection', function () {\n          position();\n        });\n      }\n\n      if (options.background) {\n        Buttons.background(true, options.backgroundClassName, options.fade, options.backgroundHost || hostNode);\n      } // This is bonkers, but if we don't have a click listener on the\n      // background element, iOS Safari will ignore the body click\n      // listener below. An empty function here is all that is\n      // required to make it work...\n\n\n      $('div.dt-button-background').on('click.dtb-collection', function () {});\n\n      if (options.autoClose) {\n        setTimeout(function () {\n          dt.on('buttons-action.b-internal', function (e, btn, dt, node) {\n            if (node[0] === hostNode[0]) {\n              return;\n            }\n\n            close();\n          });\n        }, 0);\n      }\n\n      $(display).trigger('buttons-popover.dt');\n      dt.on('destroy', close);\n      setTimeout(function () {\n        closed = false;\n        $('body').on('click.dtb-collection', function (e) {\n          if (closed) {\n            return;\n          } // andSelf is deprecated in jQ1.8, but we want 1.7 compat\n\n\n          var back = $.fn.addBack ? 'addBack' : 'andSelf';\n          var parent = $(e.target).parent()[0];\n\n          if (!$(e.target).parents()[back]().filter(content).length && !$(parent).hasClass('dt-buttons') || $(e.target).hasClass('dt-button-background')) {\n            close();\n          }\n        }).on('keyup.dtb-collection', function (e) {\n          if (e.keyCode === 27) {\n            close();\n          }\n        });\n      }, 0);\n    }\n  });\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Statics\n   */\n\n  /**\n   * Show / hide a background layer behind a collection\n   * @param  {boolean} Flag to indicate if the background should be shown or\n   *   hidden \n   * @param  {string} Class to assign to the background\n   * @static\n   */\n\n  Buttons.background = function (show, className, fade, insertPoint) {\n    if (fade === undefined) {\n      fade = 400;\n    }\n\n    if (!insertPoint) {\n      insertPoint = document.body;\n    }\n\n    if (show) {\n      _fadeIn($('<div/>').addClass(className).css('display', 'none').insertAfter(insertPoint), fade);\n    } else {\n      _fadeOut($('div.' + className), fade, function () {\n        $(this).removeClass(className).remove();\n      });\n    }\n  };\n  /**\n   * Instance selector - select Buttons instances based on an instance selector\n   * value from the buttons assigned to a DataTable. This is only useful if\n   * multiple instances are attached to a DataTable.\n   * @param  {string|int|array} Instance selector - see `instance-selector`\n   *   documentation on the DataTables site\n   * @param  {array} Button instance array that was attached to the DataTables\n   *   settings object\n   * @return {array} Buttons instances\n   * @static\n   */\n\n\n  Buttons.instanceSelector = function (group, buttons) {\n    if (group === undefined || group === null) {\n      return $.map(buttons, function (v) {\n        return v.inst;\n      });\n    }\n\n    var ret = [];\n    var names = $.map(buttons, function (v) {\n      return v.name;\n    }); // Flatten the group selector into an array of single options\n\n    var process = function process(input) {\n      if (Array.isArray(input)) {\n        for (var i = 0, ien = input.length; i < ien; i++) {\n          process(input[i]);\n        }\n\n        return;\n      }\n\n      if (typeof input === 'string') {\n        if (input.indexOf(',') !== -1) {\n          // String selector, list of names\n          process(input.split(','));\n        } else {\n          // String selector individual name\n          var idx = $.inArray(input.trim(), names);\n\n          if (idx !== -1) {\n            ret.push(buttons[idx].inst);\n          }\n        }\n      } else if (typeof input === 'number') {\n        // Index selector\n        ret.push(buttons[input].inst);\n      } else if (typeof input === 'object') {\n        // Actual instance selector\n        ret.push(input);\n      }\n    };\n\n    process(group);\n    return ret;\n  };\n  /**\n   * Button selector - select one or more buttons from a selector input so some\n   * operation can be performed on them.\n   * @param  {array} Button instances array that the selector should operate on\n   * @param  {string|int|node|jQuery|array} Button selector - see\n   *   `button-selector` documentation on the DataTables site\n   * @return {array} Array of objects containing `inst` and `idx` properties of\n   *   the selected buttons so you know which instance each button belongs to.\n   * @static\n   */\n\n\n  Buttons.buttonSelector = function (insts, selector) {\n    var ret = [];\n\n    var nodeBuilder = function nodeBuilder(a, buttons, baseIdx) {\n      var button;\n      var idx;\n\n      for (var i = 0, ien = buttons.length; i < ien; i++) {\n        button = buttons[i];\n\n        if (button) {\n          idx = baseIdx !== undefined ? baseIdx + i : i + '';\n          a.push({\n            node: button.node,\n            name: button.conf.name,\n            idx: idx\n          });\n\n          if (button.buttons) {\n            nodeBuilder(a, button.buttons, idx + '-');\n          }\n        }\n      }\n    };\n\n    var run = function run(selector, inst) {\n      var i, ien;\n      var buttons = [];\n      nodeBuilder(buttons, inst.s.buttons);\n      var nodes = $.map(buttons, function (v) {\n        return v.node;\n      });\n\n      if (Array.isArray(selector) || selector instanceof $) {\n        for (i = 0, ien = selector.length; i < ien; i++) {\n          run(selector[i], inst);\n        }\n\n        return;\n      }\n\n      if (selector === null || selector === undefined || selector === '*') {\n        // Select all\n        for (i = 0, ien = buttons.length; i < ien; i++) {\n          ret.push({\n            inst: inst,\n            node: buttons[i].node\n          });\n        }\n      } else if (typeof selector === 'number') {\n        // Main button index selector\n        if (inst.s.buttons[selector]) {\n          ret.push({\n            inst: inst,\n            node: inst.s.buttons[selector].node\n          });\n        }\n      } else if (typeof selector === 'string') {\n        if (selector.indexOf(',') !== -1) {\n          // Split\n          var a = selector.split(',');\n\n          for (i = 0, ien = a.length; i < ien; i++) {\n            run(a[i].trim(), inst);\n          }\n        } else if (selector.match(/^\\d+(\\-\\d+)*$/)) {\n          // Sub-button index selector\n          var indexes = $.map(buttons, function (v) {\n            return v.idx;\n          });\n          ret.push({\n            inst: inst,\n            node: buttons[$.inArray(selector, indexes)].node\n          });\n        } else if (selector.indexOf(':name') !== -1) {\n          // Button name selector\n          var name = selector.replace(':name', '');\n\n          for (i = 0, ien = buttons.length; i < ien; i++) {\n            if (buttons[i].name === name) {\n              ret.push({\n                inst: inst,\n                node: buttons[i].node\n              });\n            }\n          }\n        } else {\n          // jQuery selector on the nodes\n          $(nodes).filter(selector).each(function () {\n            ret.push({\n              inst: inst,\n              node: this\n            });\n          });\n        }\n      } else if (typeof selector === 'object' && selector.nodeName) {\n        // Node selector\n        var idx = $.inArray(selector, nodes);\n\n        if (idx !== -1) {\n          ret.push({\n            inst: inst,\n            node: nodes[idx]\n          });\n        }\n      }\n    };\n\n    for (var i = 0, ien = insts.length; i < ien; i++) {\n      var inst = insts[i];\n      run(selector, inst);\n    }\n\n    return ret;\n  };\n  /**\n   * Default function used for formatting output data.\n   * @param {*} str Data to strip\n   */\n\n\n  Buttons.stripData = function (str, config) {\n    if (typeof str !== 'string') {\n      return str;\n    } // Always remove script tags\n\n\n    str = str.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, ''); // Always remove comments\n\n    str = str.replace(/<!\\-\\-.*?\\-\\->/g, '');\n\n    if (!config || config.stripHtml) {\n      str = str.replace(/<[^>]*>/g, '');\n    }\n\n    if (!config || config.trim) {\n      str = str.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    if (!config || config.stripNewlines) {\n      str = str.replace(/\\n/g, ' ');\n    }\n\n    if (!config || config.decodeEntities) {\n      _exportTextarea.innerHTML = str;\n      str = _exportTextarea.value;\n    }\n\n    return str;\n  };\n  /**\n   * Buttons defaults. For full documentation, please refer to the docs/option\n   * directory or the DataTables site.\n   * @type {Object}\n   * @static\n   */\n\n\n  Buttons.defaults = {\n    buttons: ['copy', 'excel', 'csv', 'pdf', 'print'],\n    name: 'main',\n    tabIndex: 0,\n    dom: {\n      container: {\n        tag: 'div',\n        className: 'dt-buttons'\n      },\n      collection: {\n        tag: 'div',\n        className: ''\n      },\n      button: {\n        tag: 'button',\n        className: 'dt-button',\n        active: 'active',\n        disabled: 'disabled',\n        spacerClass: ''\n      },\n      buttonLiner: {\n        tag: 'span',\n        className: ''\n      },\n      split: {\n        tag: 'div',\n        className: 'dt-button-split'\n      },\n      splitWrapper: {\n        tag: 'div',\n        className: 'dt-btn-split-wrapper'\n      },\n      splitDropdown: {\n        tag: 'button',\n        text: '&#x25BC;',\n        className: 'dt-btn-split-drop',\n        align: 'split-right',\n        splitAlignClass: 'dt-button-split-left'\n      },\n      splitDropdownButton: {\n        tag: 'button',\n        className: 'dt-btn-split-drop-button dt-button'\n      },\n      splitCollection: {\n        tag: 'div',\n        className: 'dt-button-split-collection'\n      }\n    }\n  };\n  /**\n   * Version information\n   * @type {string}\n   * @static\n   */\n\n  Buttons.version = '2.2.2';\n  $.extend(_dtButtons, {\n    collection: {\n      text: function text(dt) {\n        return dt.i18n('buttons.collection', 'Collection');\n      },\n      className: 'buttons-collection',\n      closeButton: false,\n      init: function init(dt, button, config) {\n        button.attr('aria-expanded', false);\n      },\n      action: function action(e, dt, button, config) {\n        if (config._collection.parents('body').length) {\n          this.popover(false, config);\n        } else {\n          this.popover(config._collection, config);\n        }\n      },\n      attr: {\n        'aria-haspopup': true\n      } // Also the popover options, defined in Buttons.popover\n\n    },\n    split: {\n      text: function text(dt) {\n        return dt.i18n('buttons.split', 'Split');\n      },\n      className: 'buttons-split',\n      closeButton: false,\n      init: function init(dt, button, config) {\n        return button.attr('aria-expanded', false);\n      },\n      action: function action(e, dt, button, config) {\n        this.popover(config._collection, config);\n      },\n      attr: {\n        'aria-haspopup': true\n      } // Also the popover options, defined in Buttons.popover\n\n    },\n    copy: function copy(dt, conf) {\n      if (_dtButtons.copyHtml5) {\n        return 'copyHtml5';\n      }\n    },\n    csv: function csv(dt, conf) {\n      if (_dtButtons.csvHtml5 && _dtButtons.csvHtml5.available(dt, conf)) {\n        return 'csvHtml5';\n      }\n    },\n    excel: function excel(dt, conf) {\n      if (_dtButtons.excelHtml5 && _dtButtons.excelHtml5.available(dt, conf)) {\n        return 'excelHtml5';\n      }\n    },\n    pdf: function pdf(dt, conf) {\n      if (_dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available(dt, conf)) {\n        return 'pdfHtml5';\n      }\n    },\n    pageLength: function pageLength(dt) {\n      var lengthMenu = dt.settings()[0].aLengthMenu;\n      var vals = [];\n      var lang = [];\n\n      var text = function text(dt) {\n        return dt.i18n('buttons.pageLength', {\n          \"-1\": 'Show all rows',\n          _: 'Show %d rows'\n        }, dt.page.len());\n      }; // Support for DataTables 1.x 2D array\n\n\n      if (Array.isArray(lengthMenu[0])) {\n        vals = lengthMenu[0];\n        lang = lengthMenu[1];\n      } else {\n        for (var i = 0; i < lengthMenu.length; i++) {\n          var option = lengthMenu[i]; // Support for DataTables 2 object in the array\n\n          if ($.isPlainObject(option)) {\n            vals.push(option.value);\n            lang.push(option.label);\n          } else {\n            vals.push(option);\n            lang.push(option);\n          }\n        }\n      }\n\n      return {\n        extend: 'collection',\n        text: text,\n        className: 'buttons-page-length',\n        autoClose: true,\n        buttons: $.map(vals, function (val, i) {\n          return {\n            text: lang[i],\n            className: 'button-page-length',\n            action: function action(e, dt) {\n              dt.page.len(val).draw();\n            },\n            init: function init(dt, node, conf) {\n              var that = this;\n\n              var fn = function fn() {\n                that.active(dt.page.len() === val);\n              };\n\n              dt.on('length.dt' + conf.namespace, fn);\n              fn();\n            },\n            destroy: function destroy(dt, node, conf) {\n              dt.off('length.dt' + conf.namespace);\n            }\n          };\n        }),\n        init: function init(dt, node, conf) {\n          var that = this;\n          dt.on('length.dt' + conf.namespace, function () {\n            that.text(conf.text);\n          });\n        },\n        destroy: function destroy(dt, node, conf) {\n          dt.off('length.dt' + conf.namespace);\n        }\n      };\n    },\n    spacer: {\n      style: 'empty',\n      spacer: true,\n      text: function text(dt) {\n        return dt.i18n('buttons.spacer', '');\n      }\n    }\n  });\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * DataTables API\n   *\n   * For complete documentation, please refer to the docs/api directory or the\n   * DataTables site\n   */\n  // Buttons group and individual button selector\n\n  DataTable.Api.register('buttons()', function (group, selector) {\n    // Argument shifting\n    if (selector === undefined) {\n      selector = group;\n      group = undefined;\n    }\n\n    this.selector.buttonGroup = group;\n    var res = this.iterator(true, 'table', function (ctx) {\n      if (ctx._buttons) {\n        return Buttons.buttonSelector(Buttons.instanceSelector(group, ctx._buttons), selector);\n      }\n    }, true);\n    res._groupSelector = group;\n    return res;\n  }); // Individual button selector\n\n  DataTable.Api.register('button()', function (group, selector) {\n    // just run buttons() and truncate\n    var buttons = this.buttons(group, selector);\n\n    if (buttons.length > 1) {\n      buttons.splice(1, buttons.length);\n    }\n\n    return buttons;\n  }); // Active buttons\n\n  DataTable.Api.registerPlural('buttons().active()', 'button().active()', function (flag) {\n    if (flag === undefined) {\n      return this.map(function (set) {\n        return set.inst.active(set.node);\n      });\n    }\n\n    return this.each(function (set) {\n      set.inst.active(set.node, flag);\n    });\n  }); // Get / set button action\n\n  DataTable.Api.registerPlural('buttons().action()', 'button().action()', function (action) {\n    if (action === undefined) {\n      return this.map(function (set) {\n        return set.inst.action(set.node);\n      });\n    }\n\n    return this.each(function (set) {\n      set.inst.action(set.node, action);\n    });\n  }); // Collection control\n\n  DataTable.Api.registerPlural('buttons().collectionRebuild()', 'button().collectionRebuild()', function (buttons) {\n    return this.each(function (set) {\n      for (var i = 0; i < buttons.length; i++) {\n        if (typeof buttons[i] === 'object') {\n          buttons[i].parentConf = set;\n        }\n      }\n\n      set.inst.collectionRebuild(set.node, buttons);\n    });\n  }); // Enable / disable buttons\n\n  DataTable.Api.register(['buttons().enable()', 'button().enable()'], function (flag) {\n    return this.each(function (set) {\n      set.inst.enable(set.node, flag);\n    });\n  }); // Disable buttons\n\n  DataTable.Api.register(['buttons().disable()', 'button().disable()'], function () {\n    return this.each(function (set) {\n      set.inst.disable(set.node);\n    });\n  }); // Button index\n\n  DataTable.Api.register('button().index()', function () {\n    var idx = null;\n    this.each(function (set) {\n      var res = set.inst.index(set.node);\n\n      if (res !== null) {\n        idx = res;\n      }\n    });\n    return idx;\n  }); // Get button nodes\n\n  DataTable.Api.registerPlural('buttons().nodes()', 'button().node()', function () {\n    var jq = $(); // jQuery will automatically reduce duplicates to a single entry\n\n    $(this.each(function (set) {\n      jq = jq.add(set.inst.node(set.node));\n    }));\n    return jq;\n  }); // Get / set button processing state\n\n  DataTable.Api.registerPlural('buttons().processing()', 'button().processing()', function (flag) {\n    if (flag === undefined) {\n      return this.map(function (set) {\n        return set.inst.processing(set.node);\n      });\n    }\n\n    return this.each(function (set) {\n      set.inst.processing(set.node, flag);\n    });\n  }); // Get / set button text (i.e. the button labels)\n\n  DataTable.Api.registerPlural('buttons().text()', 'button().text()', function (label) {\n    if (label === undefined) {\n      return this.map(function (set) {\n        return set.inst.text(set.node);\n      });\n    }\n\n    return this.each(function (set) {\n      set.inst.text(set.node, label);\n    });\n  }); // Trigger a button's action\n\n  DataTable.Api.registerPlural('buttons().trigger()', 'button().trigger()', function () {\n    return this.each(function (set) {\n      set.inst.node(set.node).trigger('click');\n    });\n  }); // Button resolver to the popover\n\n  DataTable.Api.register('button().popover()', function (content, options) {\n    return this.map(function (set) {\n      return set.inst._popover(content, this.button(this[0].node), options);\n    });\n  }); // Get the container elements\n\n  DataTable.Api.register('buttons().containers()', function () {\n    var jq = $();\n    var groupSelector = this._groupSelector; // We need to use the group selector directly, since if there are no buttons\n    // the result set will be empty\n\n    this.iterator(true, 'table', function (ctx) {\n      if (ctx._buttons) {\n        var insts = Buttons.instanceSelector(groupSelector, ctx._buttons);\n\n        for (var i = 0, ien = insts.length; i < ien; i++) {\n          jq = jq.add(insts[i].container());\n        }\n      }\n    });\n    return jq;\n  });\n  DataTable.Api.register('buttons().container()', function () {\n    // API level of nesting is `buttons()` so we can zip into the containers method\n    return this.containers().eq(0);\n  }); // Add a new button\n\n  DataTable.Api.register('button().add()', function (idx, conf, draw) {\n    var ctx = this.context; // Don't use `this` as it could be empty - select the instances directly\n\n    if (ctx.length) {\n      var inst = Buttons.instanceSelector(this._groupSelector, ctx[0]._buttons);\n\n      if (inst.length) {\n        inst[0].add(conf, idx, draw);\n      }\n    }\n\n    return this.button(this._groupSelector, idx);\n  }); // Destroy the button sets selected\n\n  DataTable.Api.register('buttons().destroy()', function () {\n    this.pluck('inst').unique().each(function (inst) {\n      inst.destroy();\n    });\n    return this;\n  }); // Remove a button\n\n  DataTable.Api.registerPlural('buttons().remove()', 'buttons().remove()', function () {\n    this.each(function (set) {\n      set.inst.remove(set.node);\n    });\n    return this;\n  }); // Information box that can be used by buttons\n\n  var _infoTimer;\n\n  DataTable.Api.register('buttons.info()', function (title, message, time) {\n    var that = this;\n\n    if (title === false) {\n      this.off('destroy.btn-info');\n\n      _fadeOut($('#datatables_buttons_info'), 400, function () {\n        $(this).remove();\n      });\n\n      clearTimeout(_infoTimer);\n      _infoTimer = null;\n      return this;\n    }\n\n    if (_infoTimer) {\n      clearTimeout(_infoTimer);\n    }\n\n    if ($('#datatables_buttons_info').length) {\n      $('#datatables_buttons_info').remove();\n    }\n\n    title = title ? '<h2>' + title + '</h2>' : '';\n\n    _fadeIn($('<div id=\"datatables_buttons_info\" class=\"dt-button-info\"/>').html(title).append($('<div/>')[typeof message === 'string' ? 'html' : 'append'](message)).css('display', 'none').appendTo('body'));\n\n    if (time !== undefined && time !== 0) {\n      _infoTimer = setTimeout(function () {\n        that.buttons.info(false);\n      }, time);\n    }\n\n    this.on('destroy.btn-info', function () {\n      that.buttons.info(false);\n    });\n    return this;\n  }); // Get data from the table for export - this is common to a number of plug-in\n  // buttons so it is included in the Buttons core library\n\n  DataTable.Api.register('buttons.exportData()', function (options) {\n    if (this.context.length) {\n      return _exportData(new DataTable.Api(this.context[0]), options);\n    }\n  }); // Get information about the export that is common to many of the export data\n  // types (DRY)\n\n  DataTable.Api.register('buttons.exportInfo()', function (conf) {\n    if (!conf) {\n      conf = {};\n    }\n\n    return {\n      filename: _filename(conf),\n      title: _title(conf),\n      messageTop: _message(this, conf.message || conf.messageTop, 'top'),\n      messageBottom: _message(this, conf.messageBottom, 'bottom')\n    };\n  });\n  /**\n   * Get the file name for an exported file.\n   *\n   * @param {object}\tconfig Button configuration\n   * @param {boolean} incExtension Include the file name extension\n   */\n\n  var _filename = function _filename(config) {\n    // Backwards compatibility\n    var filename = config.filename === '*' && config.title !== '*' && config.title !== undefined && config.title !== null && config.title !== '' ? config.title : config.filename;\n\n    if (typeof filename === 'function') {\n      filename = filename();\n    }\n\n    if (filename === undefined || filename === null) {\n      return null;\n    }\n\n    if (filename.indexOf('*') !== -1) {\n      filename = filename.replace('*', $('head > title').text()).trim();\n    } // Strip characters which the OS will object to\n\n\n    filename = filename.replace(/[^a-zA-Z0-9_\\u00A1-\\uFFFF\\.,\\-_ !\\(\\)]/g, \"\");\n\n    var extension = _stringOrFunction(config.extension);\n\n    if (!extension) {\n      extension = '';\n    }\n\n    return filename + extension;\n  };\n  /**\n   * Simply utility method to allow parameters to be given as a function\n   *\n   * @param {undefined|string|function} option Option\n   * @return {null|string} Resolved value\n   */\n\n\n  var _stringOrFunction = function _stringOrFunction(option) {\n    if (option === null || option === undefined) {\n      return null;\n    } else if (typeof option === 'function') {\n      return option();\n    }\n\n    return option;\n  };\n  /**\n   * Get the title for an exported file.\n   *\n   * @param {object} config\tButton configuration\n   */\n\n\n  var _title = function _title(config) {\n    var title = _stringOrFunction(config.title);\n\n    return title === null ? null : title.indexOf('*') !== -1 ? title.replace('*', $('head > title').text() || 'Exported data') : title;\n  };\n\n  var _message = function _message(dt, option, position) {\n    var message = _stringOrFunction(option);\n\n    if (message === null) {\n      return null;\n    }\n\n    var caption = $('caption', dt.table().container()).eq(0);\n\n    if (message === '*') {\n      var side = caption.css('caption-side');\n\n      if (side !== position) {\n        return null;\n      }\n\n      return caption.length ? caption.text() : '';\n    }\n\n    return message;\n  };\n\n  var _exportTextarea = $('<textarea/>')[0];\n\n  var _exportData = function _exportData(dt, inOpts) {\n    var config = $.extend(true, {}, {\n      rows: null,\n      columns: '',\n      modifier: {\n        search: 'applied',\n        order: 'applied'\n      },\n      orthogonal: 'display',\n      stripHtml: true,\n      stripNewlines: true,\n      decodeEntities: true,\n      trim: true,\n      format: {\n        header: function header(d) {\n          return Buttons.stripData(d, config);\n        },\n        footer: function footer(d) {\n          return Buttons.stripData(d, config);\n        },\n        body: function body(d) {\n          return Buttons.stripData(d, config);\n        }\n      },\n      customizeData: null\n    }, inOpts);\n    var header = dt.columns(config.columns).indexes().map(function (idx) {\n      var el = dt.column(idx).header();\n      return config.format.header(el.innerHTML, idx, el);\n    }).toArray();\n    var footer = dt.table().footer() ? dt.columns(config.columns).indexes().map(function (idx) {\n      var el = dt.column(idx).footer();\n      return config.format.footer(el ? el.innerHTML : '', idx, el);\n    }).toArray() : null; // If Select is available on this table, and any rows are selected, limit the export\n    // to the selected rows. If no rows are selected, all rows will be exported. Specify\n    // a `selected` modifier to control directly.\n\n    var modifier = $.extend({}, config.modifier);\n\n    if (dt.select && typeof dt.select.info === 'function' && modifier.selected === undefined) {\n      if (dt.rows(config.rows, $.extend({\n        selected: true\n      }, modifier)).any()) {\n        $.extend(modifier, {\n          selected: true\n        });\n      }\n    }\n\n    var rowIndexes = dt.rows(config.rows, modifier).indexes().toArray();\n    var selectedCells = dt.cells(rowIndexes, config.columns);\n    var cells = selectedCells.render(config.orthogonal).toArray();\n    var cellNodes = selectedCells.nodes().toArray();\n    var columns = header.length;\n    var rows = columns > 0 ? cells.length / columns : 0;\n    var body = [];\n    var cellCounter = 0;\n\n    for (var i = 0, ien = rows; i < ien; i++) {\n      var row = [columns];\n\n      for (var j = 0; j < columns; j++) {\n        row[j] = config.format.body(cells[cellCounter], i, j, cellNodes[cellCounter]);\n        cellCounter++;\n      }\n\n      body[i] = row;\n    }\n\n    var data = {\n      header: header,\n      footer: footer,\n      body: body\n    };\n\n    if (config.customizeData) {\n      config.customizeData(data);\n    }\n\n    return data;\n  };\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * DataTables interface\n   */\n  // Attach to DataTables objects for global access\n\n\n  $.fn.dataTable.Buttons = Buttons;\n  $.fn.DataTable.Buttons = Buttons; // DataTables creation - check if the buttons have been defined for this table,\n  // they will have been if the `B` option was used in `dom`, otherwise we should\n  // create the buttons instance here so they can be inserted into the document\n  // using the API. Listen for `init` for compatibility with pre 1.10.10, but to\n  // be removed in future.\n\n  $(document).on('init.dt plugin-init.dt', function (e, settings) {\n    if (e.namespace !== 'dt') {\n      return;\n    }\n\n    var opts = settings.oInit.buttons || DataTable.defaults.buttons;\n\n    if (opts && !settings._buttons) {\n      new Buttons(settings, opts).container();\n    }\n  });\n\n  function _init(settings, options) {\n    var api = new DataTable.Api(settings);\n    var opts = options ? options : api.init().buttons || DataTable.defaults.buttons;\n    return new Buttons(api, opts).container();\n  } // DataTables `dom` feature option\n\n\n  DataTable.ext.feature.push({\n    fnInit: _init,\n    cFeature: \"B\"\n  }); // DataTables 2 layout feature\n\n  if (DataTable.ext.features) {\n    DataTable.ext.features.register('buttons', _init);\n  }\n\n  return Buttons;\n});","map":null,"metadata":{},"sourceType":"script"}